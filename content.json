{"pages":[{"title":"页面找不到辣！","text":"404 - page not found文章可能被作者删除了，点 主页 看一看作者其他的内容吧！ 或者你可以来 这里 留言（ ‘▿ ‘ ）","link":"/404.html"},{"title":"关于我","text":"合肥工业大学物联网工程专业本科生 喜欢猫狗，喜欢吉他 小米 6 钉子户","link":"/about/index.html"}],"posts":[{"title":"使用 GitHub Actions 部署 Hexo 博客","text":"本文介绍如何使用 GitHub Actions 实现自动部署 Hexo 博客，具体方案为：使用两个仓库，一个私有仓库存放 Hexo 博客的源程序，一个公开仓库存放生成的静态网站。当我们向私有仓库 push 时，GitHub Actions 自动生成静态页面并推送到公开仓库，实现博客的自动化部署。 下文中都假设你已下载安装了 Hexo 所必需的组件并且已经在本地初始化了 Hexo 博客。 首先，你需要有一个私有仓库 hexo-src （名称随意）和一个公开仓库 &lt;username&gt;.github.io 。 检查 Hexo 博客根目录下的 package.json 文件，确保其中有以下内容，如没有则自行添加，新安装的应该默认是有的。 { ... “scripts”: { &quot;build&quot;: &quot;hexo generate&quot;, ... }, ...} 在私有仓库中添加 .github/workflow/pages.yml 文件，内容如下： name: Github Page # 名字随意 on: push: branches: - main # 私有仓库的默认分支名字 jobs: pages: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Use Node.js 12.x uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache NPM dependencies uses: actions/cache@v2 with: path: node_modules key: ${{ runner.OS }}-npm-cache restore-keys: | ${{ runner.OS }}-npm-cache - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # 下面内容按需修改 external_repository: ChinaNuke/ChinaNuke.github.io # 目标仓库 (存放静态页面) publish_branch: main # 目标仓库的默认分支名字 publish_dir: ./public cname: nuke666.cn # 如果设置了自定义域名则需要设置此项 由于是部署目标是另一个仓库，因此需要设置 ${{ secrets.PERSONAL_TOKEN }} 并指定所要推送到的仓库 external_repository 以及其默认分支。 生成一个 personal token（scopes 选择 repo 即可），然后将其添加到私有仓库的 Secrets 里面（点击上方 Settings，然后点击 Secrets），名字为 PERSONAL_TOKEN，这样执行 Action 时就会自动去读取这个 token。 然后就完成了，直接把私有仓库 push 一下，Actions 会自动添加并执行，最多一分钟左右静态页面就会生成在公开仓库里。 当然也可以部署到同一个仓库里，只是缺点是你的仓库源文件也需要公开，万一不注意在配置文件里写了什么密码密钥的就不太好，部署到同一个仓库的方法见下方参考链接中的官方文档，大致步骤相似。 参考 https://hexo.io/docs/github-pages https://github.com/marketplace/actions/github-pages-action","link":"/2021/03/deploy-hexo-using-github-actions/"},{"title":"Hexo 部署到又拍云 CDN","text":"Github 在国内的访问速度实在难以接受，这样大家怎么能看到我在博客写的段子！ 于是乎，去了解了一下国内的 CDN 服务，发现又拍云可以白嫖，开始行动！ 在配置过程中遇到了一世纪难题：我的域名配置了阿里云的企业邮箱，于是我就不能把 nuke666.cn 使用 CNAME 方式解析到 CDN 服务器，会提示冲突。搜了半天似乎这个问题无解，只好委曲求全曲线救国，将 nuke666.cn 以 A 记录方式解析到 GitHub Page，使用 www.nuke666.cn 作为访问 CDN 的域名，这样访问我的博客就需要通过 www.nuke666.cn，使用nuke666.cn 的话访问到的是 GitHub Page 源站。如果没有遇到这一世纪难题的话，把这两者反过来自然是极好的。 配置的具体过程如下： GitHub Page 的配置 首先 ping chinanuke.github.io 获得网站的 IP 地址，为 nuke666.cn 添加 A 记录解析到此地址，然后在 GitHub 的 Settings 中添加自定义域名，并开启强制 HTTPS。GitHub 会自动为我们申请证书，需要等待一段时间才能生效。 又拍云的配置 在又拍云创建 CDN 服务 加速域名填写欲解析到 CDN 服务器的地址（www.nuke666.cn），由于 Hexo 是静态网站，所以应用场景选择 网页图片，其他填写内容入下图所示。 配置 CDN将 www.nuke666.cn 设置 CNAME 解析到又拍云提供的 CNAME 地址，回源 Host设置为源站的地址（nuke666.cn）。 申请和配置证书 在HTTPS 配置 中，为 www.nuke666.cn 申请免费的 Let’s Encrypt 证书，开启 HTTPS 访问和强制 HTTPS 访问。 至此，CDN 的配置已经全部完成。通过浏览器访问www.nuke666.cn，应该是可以正常访问的，那么怎么知道 CDN 有没有生效呢？ 通过浏览器的 开发者工具 ，查看Response Headers，有server: marco/2.11 即生效（又拍云的技术支持提供的方法），如果直连源站的话会显示server: GitHub.com 国内无法加载 Font Awesome 库的问题 虽然使用了 CDN，但是依然感觉很慢。询问又拍云技术支持得知，只有本域名下的内容才会被缓存到 CDN，而 Hexo 的主题如果使用 Font Awesome 等，是不会被加速的。通过开发者工具查看请求，发现向 fontawesome.com 的请求占用了大量的时间，而且最终还请求失败了？ 在 icarus 主题的配置文件中提供了对修改 CDN 的支持，修改如下，发现速度有明显提升。 themes/icarus/_config.ymlproviders: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL template of the webfont CDN provider fontcdn: loli # Name or URL of the fontawesome icon font CDN provider iconcdn: loli 又拍云打钱！","link":"/2020/07/deploy-to-upyuncdn/"},{"title":"Hexo 博客安装、备份、恢复和升级","text":"Hexo 是目前很流行的一个博客框架，目前搜索引擎中搜索到的自建博客十有七八都是使用的 Hexo，本博客用的也正是 Hexo。由于 Hexo 官方文档中安装部分搞得人晕头转向，所以本文整理记录一下 Hexo 博客安装、部署、备份 / 恢复以及升级的主要步骤和注意事项，力求简单清爽，供参考。 初装 安装 nodejs 和 npm $ pacman -S npm 也可以直接在 Pamac 包管理器中搜索 npm 安装。nodejs 作为 npm 的依赖会自动安装。pacman 是 Manjaro Linux 和 Arch Linux 的包管理软件，其他发行版命令不同但方法类似。 创建博客源程序目录，并安装 Hexo 到此目录 $ mkdir hexo-src &amp;&amp; cd hexo-src$ npm install hexo 此命令将 hexo 安装到 hexo-src 目录的 node_modules 中。 修改 PATH（可选） 将以下内容写入 ~/.bashrc 最后一行（如果用的是 zsh 就写到 ~/.zshrc），然后执行 source ~/.bashrc 命令。 export &quot;PATH=$PATH:$HOME/hexo-src/node_modules/.bin&quot; 这一步是为了能在命令行中直接使用 hexo 命令。也可以不进行这一步，只是以后需要用 npx hexo 命令代替。此处假定 hexo 目录在用户 home 目录中，如不同请修改命令。 进行博客初始化 $ hexo init # 或者 npx hexo init$ npm install 完成 部署 / 备份 推荐 使用 GitHub Actions 部署和备份博客。 恢复 安装 nodejs 和 npm 克隆源程序仓库 $ git clone git@github.com:&lt;username&gt;/hexo-src.git 安装 hexo 和依赖模块 $ cd hexo-src$ npm install 此命令会读取目录中的 package.json 并自动安装 hexo 及所需的模块到 node_modules 目录中。 修改 PATH（可选） 完成 升级$ npm update 执行完注意一下输出信息，可能有包存在冲突没有给自动升级，需要自行解决冲突或者强制升级。 参考 https://github.com/hexojs/hexo/issues/2508","link":"/2021/03/hexo-install-backup-recover-update/"},{"title":"Git 基本操作","text":"Git 是目前世界上最先进的分布式版本控制系统（廖雪峰说的），2008 年，GitHub 网站上线，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub。与集中式的版本控制 SVN 不同，分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库。 本文记录 Git 的各种常用的基本操作，方便使用时查阅。如果你是头一次接触 Git，建议先找一份教程完整的看一看，推荐 廖雪峰的 Git 教程，虽然有些内容讲的也比较绕，但是入门来说应该足够了。 初始设置 配置用户名和 Emailgit config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 在本地 Git 配置后，还需要在 GitHub 账号的 Settings - Emails 中添加并验证这个邮箱，才能与自己的 GitHub 账号关联。 设置和取消代理 设置合适的科研网络环境可以有效解决克隆仓库时速度慢的问题。 # httpgit config --global https.proxy http://127.0.0.1:8080git config --global http.proxy https://127.0.0.1:8080# socks5git config --global https.proxy socks5://127.0.0.1:1080git config --global http.proxy socks5://127.0.0.1:1080git config --global unset http.proxygit config --global unset https.proxy 基本操作 在本地创建版本库(repository)git init &lt;directory&gt;# 或者：cd &lt;directory&gt;git init 这样， &lt;directory&gt; 目录就变成了 Git 可管理的仓库，可以发现目录下多了一个隐藏的 .git 目录，不要手动改动这个目录里的东西。 查看仓库状态 如果第一次接触 Git，建议先搞清楚工作区（Working Directory）、版本库（Repository）和暂存区（Stage）的概念，可参考 廖雪峰的教程。 git status 使用这个命令可以看到： 工作区中已被修改但是未被添加到暂存区的文件（Changes not staged for commit） 已添加到工作区但是未提交的文件（Changes to be committed） 尚未被 Git 追踪的文件（Untracked files） 暂存区相关操作git add xxx.txt # 将工作区中修改的文件（Changes not staged for commit）添加到暂存区git rm --cached xxx.txt # 将暂存区的文件撤回到工作区git restore xxx.txt # 丢弃工作区中对文件的修改，使用暂存区中的版本 要注意区分第二个和第三个命令，它们的作用是不一样的。如果记不清这几个命令，输入 git status 会得到提示，提示中对命令的解释也很明确。 本地版本库操作git commit -m &quot;blablabla...&quot; # 将暂存区中的文件提交到版本库。需提供版本说明信息 # 执行这个命令前需要先把要提交的东西使用 git add 命令添加到暂存区 # 然后可以使用 git status 确认一下要提交的内容 git log [--oneline] # 查看版本库的所有 commit 记录。添加 --oneline 参数可以在一行显式git reflog # 查看命令历史，可以看到所有之前使用过的命令记录 默认的 log 命令显示的内容比较长，每次写都带参数的话又比较麻烦，我们可以使用 Git 的别名功能。将下面的这条命令输入到命令行中： git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot; 之后我们就可以用 git lg 来替代 git log ，可以看到，这样不仅显示的内容更加清晰，还能够显示出 commit 树的分支情况。 远程仓库操作git clone git@github.com:ChinaNuke/learnGit.git # 克隆远程仓库git remote add origin git@github.com:ChinaNuke/learnGit.git # 添加远程仓库 这两条命令的主要区别是，克隆一般用于 GitHub 上已经有了在开发的项目，我们需要把整个项目仓库下载到本地的情况（先有远程库，后有本地库）；而添加用于刚创建 GitHub 仓库，里面并没有东西的情况（先有本地库，后有远程库），但也可以用于第一种情况。 git push -u origin master # 把本地库的所有内容推送到远程库上，并为 master 分支建立链接 # origin 是远程库的名字，可以改成其他的，但一般用 origin 比较直观 # 一般来说，仅第一次推送时需要建立链接，后续推送不需要git push # 把当前分支的内容推送到远程库对应的分支git pull # 从远程库拉取分支的内容git reset --hard HEAD^ # 回退到上一个版本。HEAD^^ 为上上个版本，以此类推git reset --hard 1094a # 回退 / 还原到提交编号开头为 1094a 的版本 分支管理 留坑。 多人协作项目一般流程 使用 Git 和 GitHub 可以很方便地进行多人协作。多人协作中所用到的大部分命令已在前面提到，此处不对命令进行详细解释。 对于已经在 GitHub 上建好的项目，我们要先把它克隆到本地。 git clone git@github.com:ChinaNuke/learnGit.git [local directory] 其中，参数中的链接是远程仓库的地址，可以在 GitHub 项目页面找到。 [local directory] 为可选参数，如果指定了目录名，则克隆到这个目录，未指定则默认以仓库名来命名目录，此处为 learnGit 。 之后我们需要 cd learnGit 进入到仓库目录中，后续的操作都在仓库中进行。我们可以使用 git remote -v 命令查看当前仓库本地链接到的远程仓库，一般会看到 fetch 和 push 两个地址，如果没有推送权限，就看不到 push 地址。 然后我们就可以在本地进行开发了，开发过程中我们可以随时使用 git add 命令将工作区中修改过的文件添加到暂存区，然后使用 git commit 命令进行提交，使用 git lg 命令可以查看 commit 树。 在多人开发中，很有可能遇到这样一种情况：我在本地进行开发，其他人也在他的本地基于同一个版本进行开发，然后他在我们之前将修改提交到了远程仓库，这时候我们 push 时就会被拒绝。 To github.com:github.com:ChinaNuke/learnGit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:ChinaNuke/learnGit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 原因显而易见，那如何解决呢？我们先用 git pull 命令把最新的提交从远程库拉取下来，在本地合并，这时可能会有冲突，需要我们手动进行合并（冲突合并方法见廖雪峰教程）。合并完冲突之后就可以再次进行推送了，但是在这之前我们先使用 git lg 命令看看现在的 commit 树，它是不直的，类似这个样子： * d1be385 (HEAD -&gt; master, origin/master) init hello* e5e69f1 Merge branch 'dev'|\\ | * 57c53ab (origin/dev, dev) fix env conflict| |\\ | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/ * | 12a631b merged bug fix 101|\\ \\ | * | 4c805e2 fix bug 101|/ / * | e1e9c68 merge with no-ff|\\ \\ | |/ | * f52c633 add merge|/ * cf810e4 conflict fixed 这样很不好看，对强迫症很不友好。我们可以在推送前再加一步 git rebase ，正常情况下 Git 会自动将 commit 树整理成直的，执行完之后我们可以再次使用 git lg 看一下。最后，我们就可以用 git push 推送提交了。 关于 commit 树要整理成直的还是保留原始的修改记录，网上众说纷纭，我更倾向于整理成直的，清晰又直观！ 建议参考资料 Git Cheat Sheet: https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet 廖雪峰 Git 教程: https://www.liaoxuefeng.com/wiki/896043488029600","link":"/2020/09/how-to-use-git/"},{"title":"Markdown 基本语法","text":"Markdown 是一种轻量级的标记语言，对图片、图标和数学公式都有很好的支持，而且其语法极为简单，可以让我们更好的专注于写作内容。本文记录 Markdown 的各类基本语法和显示效果，以方便后续写作时查阅。 标题# 一级标题## 二级标题### 三级标题 效果： 一级标题 二级标题 三级标题 段落和换行 用一行的空行来隔开段落，Markdown Guide 不建议使用空格或者 TAB 对段落缩进。 这是第一段 这是第二段 效果：这是第一段 这是第二段 在行末添加两个及以上的空格或者加入 &lt;br&gt; 标签 可以单纯的进行换行 效果和上面一样。 这是第一行 &lt;br&gt; 这是第二行 效果：这是第一行 这是第二行 加粗和斜体** 加粗字体 *** 斜体字体 **** 加粗和斜体*** 效果：加粗字体 斜体字体 加粗和斜体 引用&gt; 这里是引用 效果： 这里是引用 &gt; 这里是多段引用&gt;&gt; 这是引用的第二段 效果： 这里是多段引用 这是引用的第二段 &gt; 这里是套娃引用&gt;&gt;&gt; 这是娃 效果： 这里是套娃引用 这是娃 引用中也可以再嵌套其他的格式。 有序和无序列表1. 有序列表第一项2. 有序列表第二项3. 有序列表第三项4. 不必保持标号顺序但是第一项必须为 1 效果： 有序列表第一项 有序列表第二项 有序列表第三项 不必保持标号顺序但是第一项必须为 1 - 无序列表第一项- 无序列表第二项- 无序列表第三项 效果： 无序列表第一项 无序列表第二项 无序列表第三项 在列表中添加元素同时保持列表连续，可以在插入的元素前面添加 四个空格 或者一个 TAB 缩进。 - 无序列表第一项- 无序列表第二项 列表之间插入文本，保持列表连续- 无序列表第三项 效果： 无序列表第一项 无序列表第二项 列表之间插入文本，保持列表连续 无序列表第三项 图片 ![ 图片替换文本 ]( 图片地址) 链接[小米 10 点击就送（假的）](https://nuke666.cn) 效果：小米 10 点击就送（假的） 代码块​``` python hello/hello.pydef my_print(): print('Hello World!')``` 效果：​``` python hello/hello.pydef my_print(): print(‘Hello World!’) ``` 以上便是 Markdown 常用的基本语法，其他不常用的语法并没有列出，以后有时间再开一篇记录扩展语法。 参考：Markdown Guide: Basic Syntax","link":"/2020/07/markdown-syntax/"},{"title":"Linux 多网络自动路由设置","text":"本文介绍如何通过设置本机上的路由规则，实现在同时连接多个网络时，根据目标地址所属网段来自动选择走哪一个网络。其中有线网卡连接内网（校园网 / 企业内网），无线网卡连接外网（手机热点），效果为：同时连接两个网络时，访问内网地址（指定网段）会走有线网络，访问其他网络地址会走无线网络；而单独连接其中一个网络时，也能够正常使用。 我所使用的操作系统是 Manjaro Linux，Gnome 桌面，对于其他操作系统和桌面环境未进行测试，请自行寻找是否有相似的设置。 首先设置无线网络，假设网关为 192.168.43.1 ，打开 设置 -&gt; 网络 ，点击有线网络的设置图标，切换到 IPv4 选项卡，在最下方“路由”设置中，关闭“自动”按钮，并填入以下内容。默认设置下，有线网络的优先级要高于无线网络，而我们需要无线网络优先于有线网络，因此通过调整跃点（Metric）的值为 99 来提高其优先级（有线网络的默认跃点值为 100，值越小优先级越高），点击“应用”并重新连接网络。 地址 子网掩码 网关 跃点 0.0.0.0 0.0.0.0 192.168.43.1 99 进行以上设置之后，当我们连接到这个网络时，会自动生成下面这样一条默认路由规则。它表示，在没有其他特定规则和优先级更高的默认规则与目标地址匹配时，则使用这条规则，即通过 wlp69s0 网卡访问 192.168.43.1 网关。 default via 192.168.43.1 dev wlp60s0 proto static metric 99 接着设置有线网络，假设网关为 192.168.2.1，我们需要让 172.16.0.0/12 网段的地址走这个网络。打开 设置 -&gt; WiFi，点击网络旁的设置按钮，同样切换到 IPv4 选项卡，关闭路由设置的“自动”按钮并填入以下内容，点击“应用”并重新连接网络。这里不设置跃点的值，使其保持默认值 100. 地址 子网掩码 网关 跃点 172.16.0.0 255.240.0.0 192.168.2.1 0.0.0.0 0.0.0.0 192.168.2.1 进行以上设置后，当我们再连接这个网络时，会自动生成下面这样两条路由规则。其中，第二条为特定规则，要优先于所有 default 规则。 default via 192.168.2.1 dev enp59s0 proto static metric 100 172.0.0.0/8 via 192.168.2.1 dev enp59s0 proto static metric 100 同时连接两个网络时，系统中所有的路由规则如下。对于 172 网段的地址，由于第三条特定静态规则的存在，它会通过 enp59s0 这个有线网卡来走 192.168.2.1 网关，也就是走内网，而对于其他没有定义特定规则的地址，有两条默认规则可以选择，但是第一条规则的优先级要高于第二条，所以对于其他的流量，都走无线网络。 $ ip route showdefault via 192.168.43.1 dev wlp60s0 proto static metric 99 default via 192.168.2.1 dev enp59s0 proto static metric 100 172.0.0.0/8 via 192.168.2.1 dev enp59s0 proto static metric 100 192.168.2.0/24 dev enp59s0 proto kernel scope link src 192.168.2.102 metric 100 192.168.43.0/24 dev wlp60s0 proto kernel scope link src 192.168.43.42 metric 600 而只连接有线网络时，系统中的路由规则如下。 $ ip route showdefault via 192.168.2.1 dev enp59s0 proto static metric 100 172.0.0.0/8 via 192.168.2.1 dev enp59s0 proto static metric 100 192.168.2.0/24 dev enp59s0 proto kernel scope link src 192.168.2.102 metric 100 只连接无线网络时，系统中的路由规则如下。 $ ip route showdefault via 192.168.43.1 dev wlp60s0 proto static metric 99 192.168.43.0/24 dev wlp60s0 proto kernel scope link src 192.168.43.42 metric 600 以上的路由规则也可以通过类似下面的命令来手动添加，但是这样添加的路由规则重启后便失效，而且不能随网络连接情况自动调整，因此并不推荐。 $ ip route add 172.0.0.0/8 via 192.168.2.1 dev enp59s0 参考和工具： linux 同时连接内外网的设置 - CSDN 东北大学 IP 地址聚合程序","link":"/2021/06/multi-network-routing/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"使用技巧","slug":"使用技巧","link":"/tags/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"网络设置","slug":"网络设置","link":"/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"}],"categories":[{"name":"网站","slug":"网站","link":"/categories/%E7%BD%91%E7%AB%99/"},{"name":"Linux系统","slug":"Linux系统","link":"/categories/Linux%E7%B3%BB%E7%BB%9F/"}]}