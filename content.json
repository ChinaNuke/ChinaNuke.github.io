{"pages":[{"title":"关于我","text":"合肥工业大学物联网工程专业本科生 喜欢猫狗，喜欢吉他","link":"/about/index.html"}],"posts":[{"title":"Hexo 部署到又拍云 CDN","text":"Github 在国内的访问速度实在难以接受，这样大家怎么能看到我在博客写的段子！ 于是乎，去了解了一下国内的 CDN 服务，发现又拍云可以白嫖，开始行动！ 在配置过程中遇到了一世纪难题：我的域名配置了阿里云的企业邮箱，于是我就不能把 nuke666.cn 使用 CNAME 方式解析到 CDN 服务器，会提示冲突。搜了半天似乎这个问题无解，只好委曲求全曲线救国，将 nuke666.cn 以 A 记录方式解析到 GitHub Page，使用 www.nuke666.cn 作为访问 CDN 的域名，这样访问我的博客就需要通过 www.nuke666.cn，使用nuke666.cn 的话访问到的是 GitHub Page 源站。如果没有遇到这一世纪难题的话，把这两者反过来自然是极好的。 配置的具体过程如下： GitHub Page 的配置 首先 ping chinanuke.github.io 获得网站的 IP 地址，为 nuke666.cn 添加 A 记录解析到此地址，然后在 GitHub 的 Settings 中添加自定义域名，并开启强制 HTTPS。GitHub 会自动为我们申请证书，需要等待一段时间才能生效。 又拍云的配置 在又拍云创建 CDN 服务 加速域名填写欲解析到 CDN 服务器的地址（www.nuke666.cn），由于 Hexo 是静态网站，所以应用场景选择 网页图片，其他填写内容入下图所示。 配置 CDN将 www.nuke666.cn 设置 CNAME 解析到又拍云提供的 CNAME 地址，回源 Host设置为源站的地址（nuke666.cn）。 申请和配置证书 在HTTPS 配置 中，为 www.nuke666.cn 申请免费的 Let’s Encrypt 证书，开启 HTTPS 访问和强制 HTTPS 访问。 至此，CDN 的配置已经全部完成。通过浏览器访问www.nuke666.cn，应该是可以正常访问的，那么怎么知道 CDN 有没有生效呢？ 通过浏览器的 开发者工具 ，查看Response Headers，有server: marco/2.11 即生效（又拍云的技术支持提供的方法），如果直连源站的话会显示server: GitHub.com 国内无法加载 Font Awesome 库的问题 虽然使用了 CDN，但是依然感觉很慢。询问又拍云技术支持得知，只有本域名下的内容才会被缓存到 CDN，而 Hexo 的主题如果使用 Font Awesome 等，是不会被加速的。通过开发者工具查看请求，发现向 fontawesome.com 的请求占用了大量的时间，而且最终还请求失败了？ 在 icarus 主题的配置文件中提供了对修改 CDN 的支持，修改如下，发现速度有明显提升。 themes/icarus/_config.yml12345678providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL template of the webfont CDN provider fontcdn: loli # Name or URL of the fontawesome icon font CDN provider iconcdn: loli 又拍云打钱！","link":"/2020/07/deploy-to-upyuncdn/"},{"title":"Git 基本操作","text":"Git 是目前世界上最先进的分布式版本控制系统（廖雪峰说的），2008 年，GitHub 网站上线，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub。与集中式的版本控制 SVN 不同，分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库。 本文记录 Git 的各种常用的基本操作，方便使用时查阅。如果你是头一次接触 Git，建议先找一份教程完整的看一看，推荐 廖雪峰的 Git 教程，虽然有些内容讲的也比较绕，但是入门来说应该足够了。 初始设置 配置用户名和 Email12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 在本地 Git 配置后，还需要在 GitHub 账号的 Settings - Emails 中添加并验证这个邮箱，才能与自己的 GitHub 账号关联。 设置和取消代理 设置合适的科研网络环境可以有效解决克隆仓库时速度慢的问题。 12345678910# httpgit config --global https.proxy http://127.0.0.1:8080git config --global http.proxy https://127.0.0.1:8080# socks5git config --global https.proxy socks5://127.0.0.1:1080git config --global http.proxy socks5://127.0.0.1:1080git config --global unset http.proxygit config --global unset https.proxy 基本操作 在本地创建版本库(repository)1234git init &lt;directory&gt;# 或者：cd &lt;directory&gt;git init 这样， &lt;directory&gt; 目录就变成了 Git 可管理的仓库，可以发现目录下多了一个隐藏的 .git 目录，不要手动改动这个目录里的东西。 查看仓库状态 如果第一次接触 Git，建议先搞清楚工作区（Working Directory）、版本库（Repository）和暂存区（Stage）的概念，可参考 廖雪峰的教程。 1git status 使用这个命令可以看到： 工作区中已被修改但是未被添加到暂存区的文件（Changes not staged for commit） 已添加到工作区但是未提交的文件（Changes to be committed） 尚未被 Git 追踪的文件（Untracked files） 暂存区相关操作123git add xxx.txt # 将工作区中修改的文件（Changes not staged for commit）添加到暂存区git rm --cached xxx.txt # 将暂存区的文件撤回到工作区git restore xxx.txt # 丢弃工作区中对文件的修改，使用暂存区中的版本 要注意区分第二个和第三个命令，它们的作用是不一样的。如果记不清这几个命令，输入 git status 会得到提示，提示中对命令的解释也很明确。 本地版本库操作1234567git commit -m &quot;blablabla...&quot; # 将暂存区中的文件提交到版本库。需提供版本说明信息 # 执行这个命令前需要先把要提交的东西使用 git add 命令添加到暂存区 # 然后可以使用 git status 确认一下要提交的内容 git log [--oneline] # 查看版本库的所有 commit 记录。添加 --oneline 参数可以在一行显式git reflog # 查看命令历史，可以看到所有之前使用过的命令记录 默认的 log 命令显示的内容比较长，每次写都带参数的话又比较麻烦，我们可以使用 Git 的别名功能。将下面的这条命令输入到命令行中： 1git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot; 之后我们就可以用 git lg 来替代 git log ，可以看到，这样不仅显示的内容更加清晰，还能够显示出 commit 树的分支情况。 远程仓库操作123git clone git@github.com:ChinaNuke/learnGit.git # 克隆远程仓库git remote add origin git@github.com:ChinaNuke/learnGit.git # 添加远程仓库 这两条命令的主要区别是，克隆一般用于 GitHub 上已经有了在开发的项目，我们需要把整个项目仓库下载到本地的情况（先有远程库，后有本地库）；而添加用于刚创建 GitHub 仓库，里面并没有东西的情况（先有本地库，后有远程库），但也可以用于第一种情况。 12345678910git push -u origin master # 把本地库的所有内容推送到远程库上，并为 master 分支建立链接 # origin 是远程库的名字，可以改成其他的，但一般用 origin 比较直观 # 一般来说，仅第一次推送时需要建立链接，后续推送不需要git push # 把当前分支的内容推送到远程库对应的分支git pull # 从远程库拉取分支的内容git reset --hard HEAD^ # 回退到上一个版本。HEAD^^ 为上上个版本，以此类推git reset --hard 1094a # 回退 / 还原到提交编号开头为 1094a 的版本 分支管理 留坑。 多人协作项目一般流程 使用 Git 和 GitHub 可以很方便地进行多人协作。多人协作中所用到的大部分命令已在前面提到，此处不对命令进行详细解释。 对于已经在 GitHub 上建好的项目，我们要先把它克隆到本地。 1git clone git@github.com:ChinaNuke/learnGit.git [local directory] 其中，参数中的链接是远程仓库的地址，可以在 GitHub 项目页面找到。 [local directory] 为可选参数，如果指定了目录名，则克隆到这个目录，未指定则默认以仓库名来命名目录，此处为 learnGit 。 之后我们需要 cd learnGit 进入到仓库目录中，后续的操作都在仓库中进行。我们可以使用 git remote -v 命令查看当前仓库本地链接到的远程仓库，一般会看到 fetch 和 push 两个地址，如果没有推送权限，就看不到 push 地址。 然后我们就可以在本地进行开发了，开发过程中我们可以随时使用 git add 命令将工作区中修改过的文件添加到暂存区，然后使用 git commit 命令进行提交，使用 git lg 命令可以查看 commit 树。 在多人开发中，很有可能遇到这样一种情况：我在本地进行开发，其他人也在他的本地基于同一个版本进行开发，然后他在我们之前将修改提交到了远程仓库，这时候我们 push 时就会被拒绝。 1234567To github.com:github.com:ChinaNuke/learnGit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:ChinaNuke/learnGit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 原因显而易见，那如何解决呢？我们先用 git pull 命令把最新的提交从远程库拉取下来，在本地合并，这时可能会有冲突，需要我们手动进行合并（冲突合并方法见廖雪峰教程）。合并完冲突之后就可以再次进行推送了，但是在这之前我们先使用 git lg 命令看看现在的 commit 树，它是不直的，类似这个样子： 123456789101112131415161718* d1be385 (HEAD -&gt; master, origin/master) init hello* e5e69f1 Merge branch 'dev'|\\ | * 57c53ab (origin/dev, dev) fix env conflict| |\\ | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/ * | 12a631b merged bug fix 101|\\ \\ | * | 4c805e2 fix bug 101|/ / * | e1e9c68 merge with no-ff|\\ \\ | |/ | * f52c633 add merge|/ * cf810e4 conflict fixed 这样很不好看，对强迫症很不友好。我们可以在推送前再加一步 git rebase ，正常情况下 Git 会自动将 commit 树整理成直的，执行完之后我们可以再次使用 git lg 看一下。最后，我们就可以用 git push 推送提交了。 关于 commit 树要整理成直的还是保留原始的修改记录，网上众说纷纭，我更倾向于整理成直的，清晰又直观！ 建议参考资料 Git Cheat Sheet: https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet 廖雪峰 Git 教程: https://www.liaoxuefeng.com/wiki/896043488029600","link":"/2020/09/how-to-use-git/"},{"title":"Markdown 基本语法","text":"Markdown 是一种轻量级的标记语言，对图片、图标和数学公式都有很好的支持，而且其语法极为简单，可以让我们更好的专注于写作内容。本文记录 Markdown 的各类基本语法和显示效果，以方便后续写作时查阅。 标题123# 一级标题## 二级标题### 三级标题 效果： 一级标题 二级标题 三级标题 段落和换行 用一行的空行来隔开段落，Markdown Guide 不建议使用空格或者 TAB 对段落缩进。 123这是第一段 这是第二段 效果：这是第一段 这是第二段 在行末添加两个及以上的空格或者加入 &lt;br&gt; 标签 可以单纯的进行换行 效果和上面一样。 12这是第一行 &lt;br&gt; 这是第二行 效果：这是第一行 这是第二行 加粗和斜体123** 加粗字体 *** 斜体字体 **** 加粗和斜体*** 效果：加粗字体 斜体字体 加粗和斜体 引用1&gt; 这里是引用 效果： 这里是引用 123&gt; 这里是多段引用&gt;&gt; 这是引用的第二段 效果： 这里是多段引用 这是引用的第二段 123&gt; 这里是套娃引用&gt;&gt;&gt; 这是娃 效果： 这里是套娃引用 这是娃 引用中也可以再嵌套其他的格式。 有序和无序列表12341. 有序列表第一项2. 有序列表第二项3. 有序列表第三项4. 不必保持标号顺序但是第一项必须为 1 效果： 有序列表第一项 有序列表第二项 有序列表第三项 不必保持标号顺序但是第一项必须为 1 123- 无序列表第一项- 无序列表第二项- 无序列表第三项 效果： 无序列表第一项 无序列表第二项 无序列表第三项 在列表中添加元素同时保持列表连续，可以在插入的元素前面添加 四个空格 或者一个 TAB 缩进。 1234- 无序列表第一项- 无序列表第二项 列表之间插入文本，保持列表连续- 无序列表第三项 效果： 无序列表第一项 无序列表第二项 列表之间插入文本，保持列表连续 无序列表第三项 图片 1![ 图片替换文本 ]( 图片地址) 链接1[小米 10 点击就送（假的）](https://nuke666.cn) 效果：小米 10 点击就送（假的） 代码块1234​``` python hello/hello.pydef my_print(): print('Hello World!')``` 效果：​``` python hello/hello.pydef my_print(): print(‘Hello World!’) ``` 以上便是 Markdown 常用的基本语法，其他不常用的语法并没有列出，以后有时间再开一篇记录扩展语法。 参考：Markdown Guide: Basic Syntax","link":"/2020/07/markdown-syntax/"},{"title":"记一次 QNAP 漏洞发现和分析","text":"本文记录最近一次 QNAP 设备上的漏洞分析过程，从发现漏洞到最终尝试利用漏洞，结论是这个漏洞没有什么利用价值，白整。但作为第一次较为完整的走完挖洞流程，还是值得记录一下的。 漏洞发现 漏洞是使用师兄的 IoT_Fuzzer 对 NAS 进行 Fuzz 时发现的，Fuzzer 通过对请求中参数的值进行变异来生成 payloads 。在对 sysRequest.cgi 构造的 payloads 中，有一个对 POST 请求中的 serv_name 字段进行变异，提交一个超长的字段值，服务器返回状态码为 500，疑似发生异常。（实际上后来发现，找到这个漏洞纯属偶然，因为就算提交一个正常的 serv_name 同样也会返回 500，应该是 cgi 脚本的问题） 启动 Burpsuite，设置拦截规则，对含有 serv_name 字段的请求进行拦截。登录 Web，打开控制台，修改“服务器名称”字段（正常值），提交修改，请求被 Burpsuite 拦截到。修改请求数据中的 serv_name 字段为超长值，foward 请求。 等待一段时间后，服务器返回了 500 状态码。此时刷新 Web 页面，页面中只有蓝色背景，无法再正常加载出页面。若在此时重启 NAS 设备，则启动完成后系统状态指示灯为红色，通过 ssh 连接查看，发现设备没有正常挂载磁盘。此时基本可以确认有漏洞存在。 漏洞分析 提取文件系统 下载 QTS 4.5.1 固件 TS-X53D_20201123-4.5.1.1495.zip，解压得到一个 img 文件，使用 file 命令查看这个文件： 12$ file TS-X53D_20201123-4.5.1.1495.imgTS-X53D_20201123-4.5.1.1495.img: data 使用 binwalk 分析这个文件，在结果最后一行可以看到固件使用某种方式加密了，我们无法直接得到固件的内容。 1234567891011$ binwalk TS-X53D_20201123-4.5.1.1495.img DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------106037306 0x652003A MySQL MISAM index file Version 3121452831 0x73D391F MySQL ISAM compressed data file Version 11126212996 0x785DB84 Cisco IOS microcode, for &quot;1&quot;174056598 0xA5FE496 MySQL MISAM compressed data file Version 8186982295 0xB251F97 MySQL MISAM index file Version 6209652627 0xC7F0B93 QNAP encrypted firmware footer , model: TS-X53D , version: 4.5.1 , date: 20201123 在网上搜寻如何解密 QNAP 固件时，发现了 StackExchange 上有这么一篇 问答，在被采纳的回答中，详细介绍了他通过系统恢复镜像（Full system recovery image）入手，在镜像中找到解密程序和解密密钥的过程。回答末尾给出了用 C 写的加解密算法程序 pc1.c。下载编译 pc1 ，使用密钥 QNAPNASVERSION4 ，即可对固件进行解密。 123456789101112131415161718192021222324252627$ gcc -o pc1 pc1.c$ ./pc1Usage: ./pc1 e|d &quot;key&quot; sourcefile targetfile./pc1 d QNAPNASVERSION4 TS-219_3.5.0_Build0816.img TS-219_3.5.0_Build0816.img.tgz./pc1 e QNAPNASVERSION4 TS-219_3.5.0_Build0816.img.tgz TS-219_3.5.0_Build0816.img$ ./pc1 d QNAPNASVERSION4 TS-X53D_20201123-4.5.1.1495.img TS-X53D_20201123-4.5.1.1495_decrypted.tar.gz$ ll -d TS-X53D*-rw-rw-r-- 1 iie iie 209652627 12 月 27 12:14 TS-X53D_20201123-4.5.1.1495_decrypted.tar.gz-rw-r--r-- 1 iie iie 209652701 11 月 23 09:52 TS-X53D_20201123-4.5.1.1495.img$ mkdir TS-X53D_20201123-4.5.1.1495_decrypted$ tar xvf TS-X53D_20201123-4.5.1.1495_decrypted.tar.gz -C TS-X53D_20201123-4.5.1.1495_decrypted$ ls TS-X53D_20201123-4.5.1.1495_decrypted1062xfwdl fw_info.conf rootfs2.bz.cksum1062xfwdl_lib64.tar.gz initrd.boot rootfs2.bz.sign107FWTools initrd.boot.cksum rootfs_ext.tgz140415_03_4F_01.bin initrd.boot.sign rootfs_ext.tgz.cksumasm1062.ROM IS_64BITS rootfs_ext.tgz.signasm1074.conf IS_STORAGE_V2 sas_fwasmthub.ko libcrypto.so.1.0.0 updateboot libssl.so.1.0.0 update_asm1062.confbzImage Q04WE009.BIN update_asm1062.shbzImage.cksum qpkg.tar update_ec.confbzImage.sign qpkg.tar.cksum update_ec.shconfig qpkg.tar.sign update_img.shec_force_boot QZ29E003.BIN update_pic.conffind_ASM107 QZ53E104.BIN update_pic.shfw_info rootfs2.bz 根据这篇回答中对固件内容的分析，我们可以得知： initrd 是使得操作系统运行的初始根文件系统 rootfs2.bz 是含有 /home, /lib 和 /usr 等目录的压缩包 rootfs_ext.tgz 是含有 /opt/source 目录的另一个 ext2 文件系统的压缩包 对这三个包分别进行解压提取并组合，便可以得到整个文件系统。而我们需要分析的sysRequest.cgi，在 /home 目录下。 12345$ ls allbin etc init lib64 lost+found opt proc run.sh share usrdev home lib linuxrc mnt php.ini root sbin tmp var$ find ./all -name sysRequest.cgi./all/home/httpd/cgi-bin/sys/sysRequest.cgi 漏洞成因分析 既然拿到了 cgi 程序，那先用 IDA Pro 进行一波静态分析，对整个程序的执行流程有个了解。使用 IDA 打开 sysRequest.cgi 程序，在 Functions Window 中找到 main 函数，利用内置的 HexRays 插件，按下 F5 对 main 函数进行反编译得到伪代码，在第 130 行左右发现这样的内容. 12345678if ((unsigned int)auth_get_session(v21, 1LL, &amp;unk_67F7C0) &amp;&amp; (unsigned int)auth_get_session(v21, 2LL, &amp;unk_67F7C0) || !(unsigned int)User_Belongs_To_Group(src, &quot;administrators&quot;) ){ sub_412480(); sub_412FE0(0LL); sub_4124C0(); goto LABEL_101;} if 语句的条件中调用了两个函数： auth_get_session 和 User_Belongs_To_Group 。如果两次调用 auth_get_session 返回值都是 1，或者 User_Belongs_To_Group 返回值是 0（或者说 false），那么执行一些调用后跳转到 LABEL_101，即进行一些必要的处理之后退出程序。 1234LABEL_101: if (v3) CGI_Free_Input(v3); exit(0); 从这里我们大致可以知道，要触发这个程序中存在的漏洞，必须是已登录用户且登录用户必须属于 administrators 用户组。 通过 ssh 连接 NAS，发现 dmesg 命令显示的信息中记录下了程序崩溃的一些信息，信息中包含了崩溃时的 ip（0x7f9ca6092bff）、崩溃所在的库（libc-2.21.so）以及这个库的起始地址（0x7f9ca602a000）等。 123[~] # dmesg | tail...[7365.850787] traps: sysRequest.cgi[24316] general protection ip:7f9ca6092bff sp:7ffc0a64ca80 error:0 in libc-2.21.so[7f9ca602a000+199000] 找到这个 libc，计算出该位置在库中的实际偏移，查看该位置处的代码，可以看到调用了一个 strlen，从这里我们看不出什么东西。 12345678910111213141516$ find . -name libc-2.21.so./lib/libc-2.21.so$ gdb ./lib/libc-2.21.so(gdb) p/x 0x7f9ca6092bff - 0x7f9ca602a000$1 = 0x68bff(gdb) x/10i 0x68bf0 0x68bf0 &lt;fputs&gt;: push %r12 0x68bf2 &lt;fputs+2&gt;: push %rbp 0x68bf3 &lt;fputs+3&gt;: mov %rdi,%rbp 0x68bf6 &lt;fputs+6&gt;: push %rbx 0x68bf7 &lt;fputs+7&gt;: mov %rsi,%rbx 0x68bfa &lt;fputs+10&gt;: callq 0x80240 &lt;strlen&gt; 0x68bff &lt;fputs+15&gt;: mov (%rbx),%r8d 0x68c02 &lt;fputs+18&gt;: mov %rax,%r12 0x68c05 &lt;fputs+21&gt;: and $0x8000,%r8d 0x68c0c &lt;fputs+28&gt;: jne 0x68c71 &lt;fputs+129&gt; 接下来进行动态调试。最初使用 IDA + QEMU 的组合对 sysRequest.cgi 进行调试，但是始终没有复现出程序崩溃，可能是因为传入的参数与实际参数有差异。 因为可以通过 ssh 直接进入 NAS，师兄建议用 gdbserver 直接 attach 到运行的 httpd 进程上，跟踪子进程来进行调试。httpd 接收到请求时，会 fork 出一个子进程，然后去调用对应的 cgi 程序去处理请求。在 gdb 中，可以通过 ``set follow-fork-mode child` 命令设置在遇到 fork 时调试子进程而不是调试父进程，这样我们就可以通过 httpd 进程来进入到 sysRequest.cgi 进程中。 需要注意的是，IDA 内置的 gdb 是不支持调试子进程的，因此我们只能用 IDA 去做静态分析，再配合命令行的 gdb 去进行动态调试。 用 ps 命令查看一下相关的进程，可以看到 NAS 并没有使用原生的 httpd 服务，而是使用了更轻量的 thttpd，诶？那个 Qthttpd 是个什么玩意？我要 attach 到哪个进程上面？ NAS 上的 ps 命令来自 busybox，从输出结果可以看出它只显示了进程 id，并没有显示出父进程 id，这样我们不好看出进程之间的关系。看一下ps --help，几乎是啥参数也不支持，白瞎。 123456[~] # ps | grep httpd 6802 admin 1664 S /usr/local/sbin/_thttpd_ -p 58080 -nor -nos -u admin -d /home/httpd -c **.* -h 127.0.0.1 -i /var/lock/._thttpd_.pid 6806 admin 912 S grep httpd11490 admin 5100 S /usr/local/sbin/Qthttpd -p 80 -nor -nos -u admin -d /home/Qhttpd -c **.*12323 admin 5336 S /usr/local/sbin/_thttpd_ -p 58080 -nor -nos -u admin -d /home/httpd -c **.* -h 127.0.0.1 -i /var/lock/._thttpd_.pid13111 httpdusr 4192 S /sbin/lpb_scheduler -d 123456789101112[~] # ps --helpBusyBox v1.24.1 (2020-11-23 03:01:36 CST) multi-call binary.Usage: ps [-o COL1,COL2=HEADER] [-T]Show list of processes -o COL1,COL2=HEADER Select columns for display -T Show threadsQNAP Options: --columns N 因此我下载了 procps 源码，在 Ubuntu x64 上自己编译了完整的 ps 程序（NAS 也是 x64），拷贝到 NAS 上的 /usr/local/bin 目录，为了不对系统中原有的可能依赖于 ps 命令的脚本造成影响，我将自己编译的命名为myps。 123456[~] # cp pscommand /usr/local/bin/myps[~] # myps -ef | grep httpdadmin 11490 1 0 03:07 ? 00:00:00 /usr/local/sbin/Qthttpd -p 80 -nor -nos -u admin -d /home/Qhttpd -c **.*admin 12323 1 0 03:07 ? 00:00:01 /usr/local/sbin/_thttpd_ -p 58080 -nor -nos -u admin -d /home/httpd -c **.* -h 127.0.0.1 -i /var/lock/._thttpd_.pidhttpdusr 13111 1 0 03:07 ? 00:00:00 /sbin/lpb_scheduler -dadmin 17004 15541 0 05:39 pts/4 00:00:00 grep httpd 需要注意，要把 pscommand 程序编译成静态的，在 configure 时添加如下参数： 1$ ./configure --disable-shared LDFLAGS=--static 那么 Qthttpd 是啥呢？Google 了一番发现，Qthttpd 是用来给用户自定义 Web 服务的，从它开放的 80 端口也可以看出这一点。而对于系统 Web 页面，则是设定在 5000 端口上，那么为什么 thttpd 进程启动时是指定的 58080 端口呢？查一下 5000 端口，发现在监听的是 apache_proxy 进程，大致可以推断请求先发送到 apache_proxy 进程，然后由它作为代理再转发到 thttpd 进程。 12[~] # netstat -tunlp | grep 5000 tcp 0 0 :::5000 :::* LISTEN 5619/apache_proxy 既然跟系统 Web 无关，为了避免它对后续调试造成干扰，直接关掉它。 1/etc/init.d/Qthttpd.sh stop 此外，我们还要干掉 daemon_mgr 这个进程。在实际调试过程中发现，调试一小会儿之后程序居然自己挂掉了……发生肾磨石了？经过分析发现，daemon_mgr 这个程序会定期向本地的 thttpd 进程发送一个 get 请求，那么显然是它检测到请求没有响应，丢弃了原先的进程，新开了一个。 1killall daemon_mgr 接下来，我们便可以直接用 gdbserver 来 attach 到唯一的一个 thttpd 进程上了。为了避免去解决麻烦的库依赖问题，我们同样使用 静态编译的 gdbserver。 1[~] # ./gdbserver-7.12-x86_64-sysv --attach :12345 12323 至此我们可以快快乐乐的进行附加调试了。 首先再理一下动态调试的目的：attach 到 thttpd 进程上，手动触发对 sysRequest.cgi 的请求，提供一个超长的 serv_name 字段，找出从哪里 fork 的子进程，然后进入到动态运行的 sysRequest.cgi 中，进而捕获程序崩溃时的现场。 使用 IDA 静态分析 thttpd 程序，查找 fork 函数的引用，总共有三处。打断点测试后，确认进入 sysRequest.cgi 子程序的是地址为 0x410a80 处的 fork。 使用 gdb 调试 thttpd 程序，通过 target remote 连接到运行在 NAS 设备上的 gdbserver，确认 0x410a80 地址处的内容，并在该处施加断点，然后继续运行。 1234567891011$ gdb _thttpd_(gdb) target remote 192.168.0.141:12345Remote debugging using 192.168.0.141:12345Reading /lib/libcrypt.so.1 from remote target......(gdb) x/i 0x410a80 0x410a80: callq 0x402ef0 &lt;fork@plt&gt;(gdb) b *0x410a80Breakpoint 1 at 0x410a80(gdb) continueContinuing. 接着我们使用 Burpsuite 的 Repeater 手动提交请求，将 serv_name 字段设置为 DDDDD……（好多好多 D），然后提交请求。最好是在登录 Web 后关掉浏览器，之所以选择这样而不是直接通过 Web 页面提交请求然后 Burpsuite 抓包再修改，是因为 Web 页面打开的时候它也会自动去提交一些请求，影响我们观测。 命中 fork 调用处的断点后，我们设置调试子进程，然后再运行一个ni，可以看到 gdb 从父进程上 detach 了，切换到了子进程。之所以要在命中 fork 断点后才开启调试子进程，是因为从前面的分析中我们发现总共有三处对 fork 的调用，一开始就开启调试子进程可能会与我们的预期不符。 进入子进程之后，我们也要再设置一下调试父进程（现在的子进程就是父进程了），因为 sysRequest.cgi 中也有多处对 fork 的调用，我们并不想研究那些无关的调用。接着用 catch exec 来捕获对 exec 的调用，它会自动进入 exec 所调用的程序，也就是 sysRequest.cgi。 1234567891011121314151617181920Breakpoint 1, 0x0000000000410a80 in ?? ()(gdb) set follow-fork-mode child(gdb) ni[Attaching after Thread 14294.14294 fork to child Thread 29226.29226][New inferior 2 (process 29226)][Detaching after fork from parent process 14294][Inferior 1 (process 14294) detached][Switching to Thread 29226.29226]0x0000000000410a85 in ?? ()(gdb) set follow-fork-mode parent(gdb) catch execCatchpoint 2 (exec)(gdb) cContinuing.[Detaching after fork from child process 29654][Detaching after fork from child process 29655]process 29226 is executing new program: /home/httpd/cgi-bin/sys/sysRequest.cgiReading /home/httpd/cgi-bin/sys/sysRequest.cgi from remote target......Thread 2.1 &quot;sysRequest.cgi&quot; hit Catchpoint 2 (exec'd /home/httpd/cgi-bin/sys/sysRequest.cgi), 0x00007fbdf681bc40 in ?? () from target:/lib64/ld-linux-x86-64.so.2 为了确认一下我们确实进入到了 sysRequest.cgi 进程中，我们在 0x4171ab 处打一个断点，这是程序中开始获取参数的位置。 12345678(gdb) b *0x4171abBreakpoint 3 at 0x4171ab(gdb) cContinuing....Thread 2.1 &quot;sysRequest.cgi&quot; hit Breakpoint 3, 0x00000000004171ab in ?? ()(gdb) x/i $pc=&gt; 0x4171ab: callq 0x40dca0 &lt;CGI_Get_Input@plt&gt; 继续执行，几秒钟之后我们看到发生了 Segmentation fault，在 libc 中。输入 bt 查看栈帧，可以看到溢出发生了，下面的栈帧全部被 0x44 填充，也就是字母 D。 123456789101112131415(gdb) cContinuing....[Detaching after fork from child process 4421]Thread 2.1 &quot;sysRequest.cgi&quot; received signal SIGSEGV, Segmentation fault.0x00007f7d5b62fbff in fputs () from target:/lib/libc.so.6(gdb) bt#0 0x00007f7d5b62fbff in fputs () from target:/lib/libc.so.6#1 0x00007f7d5edcbf93 in Modify_Hosts () from target:/usr/lib/libuLinux_config.so.0#2 0x4444444444444444 in ?? ()#3 0x4444444444444444 in ?? ()#4 0x4444444444444444 in ?? ()#5 0x4444444444444444 in ?? ()... 虽然大部分栈帧指针都被覆盖掉了，我们可以看到在 #1 处的 Modify_Hosts()函数，那么我们接下来去分析一下这个函数。反编译这个函数得到伪代码如下： 1234567891011121314151617181920212223242526272829303132333435363738int __fastcall Modify_Hosts(const char *server_name){ FILE *host_file; // rax char s[272]; // [rsp+10h] [rbp-1A0h] BYREF char v4[35]; // [rsp+120h] [rbp-90h] BYREF char address[93]; // [rsp+143h] [rbp-6Dh] BYREF FILE *tmp_file; // [rsp+1A0h] [rbp-10h] FILE *stream; // [rsp+1A8h] [rbp-8h] host_file = fopen64(&quot;/etc/hosts&quot;, &quot;r&quot;); stream = host_file; if (host_file) { tmp_file = fopen64(&quot;/tmp/hosts.tmp&quot;, &quot;w&quot;); if (tmp_file) { NIC_Get_Info(v4, 2LL); while (!feof(stream) ) { if (fgets(s, 257, stream) ) // read one line at a time { if (strstr(s, address) ) sprintf(s, &quot;%s\\t\\t%s\\t\\t%s&quot;, address, server_name, server_name);// overflow! fputs(s, tmp_file); } } fclose(stream); fclose(tmp_file); system(&quot;cp /tmp/hosts.tmp /etc/hosts 1&gt;/dev/null 2&gt;&amp;1&quot;); LODWORD(host_file) = system(&quot;rm -f /tmp/hosts.tmp 1&gt;/dev/null 2&gt;&amp;1&quot;); } else { LODWORD(host_file) = fclose(stream); } } return host_file;} 这个函数的作用是在修改服务器名称之后对 Hosts 文件进行同步的修改，它先创建一个用于保存结果的临时文件，然后逐行读出 /etc/hosts 文件的内容，寻找是否包含 address 子串，然后把每一行写到临时文件，最后再用临时文件替换原来的 hosts 文件。hosts 文件的格式如下，第一栏是地址，即代码中的 address，后面两栏都是服务器名称（serv_name）。 123[~] # cat /etc/hosts127.0.0.1 localhost localhost192.168.0.141 CCCCCC CCCCCC #eth0 在代码 23 行的位置，它通过 sprintf 函数组装一行数据输出到数组 s 中，其中参数 server_name 便是我们在请求数据中提供的。数组 s 的长度是 272，而这里显然没有对用户输入 server_name 的长度进行检查（沿着往上层函数找也没有检查），所以此处存在溢出（破案了）。 调用它的上层函数 Set_Server_Name 中也有一处很明显的漏洞，理论上可以通过构造 server_name 直接注入命令。（买一送一？） 12sprintf(s, &quot;/bin/hostname \\&quot;%s\\&quot; 1&gt;/dev/null 2&gt;/dev/null&quot;, server_name);system(s); 漏洞利用 前面也提到了这个漏洞可能只在授权条件下才有机会触发，其实是白整，这一部分主要来分析这俩漏洞利用的种种不可行性。我们先抛开授权不授权的问题，就在登录状态下尝试利用。 上手先试一个简单的，试一下送的那个。 1AAAAA&quot;;touch /tmp/nuke666;echo&quot; 构造这么一个输入，理论上可以闭合第一个双引号，然后在 /tmp 目录下创建一个文件。进行一下 URL 编码，得到 AAAAA%22%3btouch+%2ftmp%2fnuke666%3becho%22 这么一串，扔到 Burpsuite，提交。看一眼 /tmp 目录，哦豁，nothing！回头再网上找一找，找到 sysRequest.cgi 中对 Set_Server_Name 函数的调用，发现猫腻！这咋有个 Is_Valid_Servername？看样子像是检查一下 server_name 然后再去设置？ 1234567891011121314151617if (server_name &amp;&amp; (unsigned int)Is_Valid_Servername(*(_QWORD *)(server_name + 8)) == 1 ){ ... Get_Server_Name(s1, 32LL); ... if (!strcmp(s1, v52) ) { ... } else { v170 = 2; if ((unsigned int)Set_Server_Name((__int64)v52, 0LL) ) ret_of_settingresult = -1; ... }} 那找一下 Is_Valid_Servername 这个函数看一下。 1234$ nm -D -A ./usr/lib/*.so | grep Is_Valid_Servernamenm: ./usr/lib/libsmbpw.so：无此文件nm: ./usr/lib/libuLinux_ha.so：无此文件./usr/lib/libuLinux_Util.so:00000000000186dd T Is_Valid_Servername 反编译得到伪代码如下。主要是调用了一个 (*__ctype_b_loc())[*v2] &amp; 8 这是个什么奇奇怪怪的玩意？ 12345678910111213141516171819202122__int64 __fastcall Is_Valid_Servername(char *server_name){ char *v2; // [rsp+18h] [rbp-8h] v2 = server_name; if (!server_name) return 0LL; while (*v2) { if (((*__ctype_b_loc())[*v2] &amp; 8) != 0 ) // 只允许字母和数字 isalnum() { ++v2; } else { if (*v2 != '-' ) return 0LL; ++v2; } } return 1LL;} 上网一查这是个判断字符的宏定义，(*__ctype_b_loc())[*v2] &amp; 8这一串实际上就等同于 isalnum(server_name)。哦豁完蛋，它 只允许字母和数字！那怪不得构造的 payload 不好使呢。那这个样子另一处漏洞不也白瞎了？师兄说有纯字母和数字的 shellcode。 不着急，先分析下环境。用 checksec.sh 这个脚本扫一下程序。 123$ ./checksec --file=libuLinux_config.so.0.0 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE No RELRO No canary found NX enabled DSO No RPATH No RUNPATH No Symbols No 0 21 libuLinux_config.so.0.0 这个库没有开启 Stack Canary，但是设置了 NX（栈不可执行），这就意味着不能把 shellcode 放在栈上去执行了，可以选择 return-to-libc 攻击。还有个东西叫 ALSR 来着不是，也看一眼 12[~] # sysctl kernel.randomize_va_spacekernel.randomize_va_space = 2 哦豁，开了，那这就意味着我们没法找地址了这不是。暴力呢？这是个 64 位机……之前尝试过在 Ubuntu x64 上开启 ALSR 跑溢出，跑了 3 个小时没有命中，所以基本上没戏。 结论 分析至此，这篇文章基本上就结束了。结论：白整。为了让自己死心，又去分析了下 auth_get_session 和User_Belongs_To_Group这俩函数，结果人家坚固的很。 虽然没有搞出什么牛 X 的洞，但也算是完整的走完了漏洞分析的整个流程，这个过程中学到的工具和技巧，是非常有价值的。","link":"/2021/01/analyze-an-overflow-vulnerability-on-qnap/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"QNAP","slug":"QNAP","link":"/tags/QNAP/"},{"name":"漏洞","slug":"漏洞","link":"/tags/%E6%BC%8F%E6%B4%9E/"}],"categories":[{"name":"网站","slug":"网站","link":"/categories/%E7%BD%91%E7%AB%99/"},{"name":"安全","slug":"安全","link":"/categories/%E5%AE%89%E5%85%A8/"}]}