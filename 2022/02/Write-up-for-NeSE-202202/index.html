<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Write-up | NeSE 丙组 202202 - ChinaNuke的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ChinaNuke的博客"><meta name="msapplication-TileImage" content="/img/steve-jumping-dino.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ChinaNuke的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="2022 年 2 月丙组月赛，黄队没有 pwn 手出题，所以硬着头皮做了 babybmp 和 wind0ws 两道逆向题，还挺好玩。"><meta property="og:type" content="blog"><meta property="og:title" content="Write-up | NeSE 丙组 202202"><meta property="og:url" content="https://www.nuke666.cn/2022/02/Write-up-for-NeSE-202202/"><meta property="og:site_name" content="ChinaNuke的博客"><meta property="og:description" content="2022 年 2 月丙组月赛，黄队没有 pwn 手出题，所以硬着头皮做了 babybmp 和 wind0ws 两道逆向题，还挺好玩。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.nuke666.cn/img/og_image.png"><meta property="article:published_time" content="2022-02-12T10:14:41.000Z"><meta property="article:author" content="ChinaNuke"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.nuke666.cn/2022/02/Write-up-for-NeSE-202202/"},"headline":"Write-up | NeSE 丙组 202202","image":["https://www.nuke666.cn/img/og_image.png"],"datePublished":"2022-02-12T10:14:41.000Z","author":{"@type":"Person","name":"ChinaNuke"},"publisher":{"@type":"Organization","name":"ChinaNuke的博客","logo":{"@type":"ImageObject","url":{"text":"ChinaNuke的博客"}}},"description":"2022 年 2 月丙组月赛，黄队没有 pwn 手出题，所以硬着头皮做了 babybmp 和 wind0ws 两道逆向题，还挺好玩。"}</script><link rel="canonical" href="https://www.nuke666.cn/2022/02/Write-up-for-NeSE-202202/"><link rel="icon" href="/img/steve-jumping-dino.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">ChinaNuke的博客</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="我的 GitHub 主页" href="https://github.com/ChinaNuke"><i class="fab fa-github-alt"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen is-9-fullhd"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-12T10:14:41.000Z" title="2/12/2022, 10:14:41 AM">2022-02-12</time>发表</span><span class="level-item">约23 分钟读完 (大约3417个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Write-up | NeSE 丙组 202202</h1><div class="content"><p>2022 年 2 月丙组月赛，黄队没有 pwn 手出题，所以硬着头皮做了 babybmp 和 wind0ws 两道逆向题，还挺好玩。</p>
<span id="more"></span>

<h2 id="babybmp"><a href="#babybmp" class="headerlink" title="babybmp"></a>babybmp</h2><p> 题目叫 baby 了也不算很难，搞清楚程序做了什么就可以，但是由于有个大聪明把 7 写成 0x111 然后搞了半天没有发现问题在哪，我不说他是谁，希望大家不要学我。</p>
<p> 程序文件名叫 bmpencrypt， 然后给了一张很好看的风景图片，名字为 dst.bmp ，所以看起来是把什么东西通过 bmpencrypt 程序加密得到了图片文件。下面是核心逻辑之前的一些准备代码，打开了 3 个图片文件，确定了 flag.bmp 和 src.bmp 的大小，为它们各自分配了缓冲区，把两个文件的内容全部拷贝到缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flagBmp = fopen(<span class="string">&quot;flag.bmp&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">srcBmp = fopen(<span class="string">&quot;src.bmp&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">dstBmp = fopen(<span class="string">&quot;dst.bmp&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">fseek(flagBmp, <span class="number">0LL</span>, SEEK_END);</span><br><span class="line">fseek(srcBmp, <span class="number">0LL</span>, SEEK_END);</span><br><span class="line">flagLength = ftell(flagBmp);</span><br><span class="line">srcLength = ftell(srcBmp);</span><br><span class="line">flagBuf = (<span class="type">unsigned</span> __int8 *)<span class="built_in">malloc</span>(flagLength);</span><br><span class="line">srcBuf = (<span class="type">unsigned</span> __int8 *)<span class="built_in">malloc</span>(srcLength);</span><br><span class="line">fseek(flagBmp, <span class="number">0LL</span>, SEEK_SET);</span><br><span class="line">fseek(srcBmp, <span class="number">0LL</span>, SEEK_SET);</span><br><span class="line">fread(flagBuf, flagLength, <span class="number">1uLL</span>, flagBmp);</span><br><span class="line">fread(srcBuf, srcLength, <span class="number">1uLL</span>, srcBmp);</span><br></pre></td></tr></table></figure>

<p> 接下来就是核心的加密算法部分，先将 src 的位置指针设置为 54 ，然后遍历 flag 文件的每一个字节。通过循环结束后的 <code>fwrite</code> 函数调用我们可以得知 <code>srcBuf</code> 中就是最终要写入到 dst.bmp 文件的内容，那么我们可以关注循环体中对 <code>srcBuf</code> 缓冲区的修改，在一次循环中发生 4 次（我已在伪代码的注释中标出），计算一下 <code>srcPosa</code> 变量可知四次修改的分别是 <code>srcBuf[srcPos]</code> 、<code>srcBuf[srcPos + 1]</code> 、<code>srcBuf[srcPos + 2]</code> 、<code>srcBuf[srcPos + 3]</code> ，那么也就是说每一次循环处理 src 图片中连续的 4 个字节。</p>
<p> 然后看一下 4 次对 <code>srcBuf</code> 缓冲区赋值的来源，比较统一，都是把 <code>flagUChar</code> 变量和 <code>srcBuf</code> 缓冲区当前位置的值进行一些运算，基本上可以推测出 src 图像中的每 4 个字节包含 flag 图像中一个字节的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">srcPos = <span class="number">54</span>;</span><br><span class="line"><span class="keyword">for</span> (flagPos = <span class="number">0</span>; flagLength &gt; flagPos; ++flagPos )</span><br><span class="line">&#123;</span><br><span class="line">    flagUChar = flagBuf[flagPos];</span><br><span class="line">    srcBuf[srcPos] = flagUChar &amp; <span class="number">7</span> | srcBuf[srcPos] &amp; <span class="number">0xF8</span>;<span class="comment">// 1: (flagUChar&gt;&gt;0)&amp;0x0111</span></span><br><span class="line">    flagUChara = (<span class="type">int</span>)flagUChar &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    srcPosa = srcPos + <span class="number">1</span>;</span><br><span class="line">    srcBuf[srcPosa] = flagUChara &amp; <span class="number">3</span> | srcBuf[srcPosa] &amp; <span class="number">0xFC</span>;<span class="comment">// 2: (flagUChar&gt;&gt;3)&amp;0x0011</span></span><br><span class="line">    flagUCharb = (<span class="type">int</span>)flagUChara &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    ++srcPosa;</span><br><span class="line">    srcBuf[srcPosa] = flagUCharb &amp; <span class="number">1</span> | srcBuf[srcPosa] &amp; <span class="number">0xFE</span>;<span class="comment">// 3: (flagUChar&gt;&gt;5)&amp;0x0001</span></span><br><span class="line">    ++srcPosa;</span><br><span class="line">    srcBuf[srcPosa] = ((<span class="type">int</span>)flagUCharb &gt;&gt; <span class="number">1</span>) &amp; <span class="number">3</span> | srcBuf[srcPosa] &amp; <span class="number">0xFC</span>;<span class="comment">// 4: (flagUChar&gt;&gt;6)&amp;0x0011</span></span><br><span class="line">    srcPos = srcPosa + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fwrite(srcBuf, srcLength, <span class="number">1uLL</span>, dstBmp);      <span class="comment">// srcBuf -&gt; dstBmp</span></span><br><span class="line"><span class="built_in">free</span>(flagBuf);</span><br><span class="line"><span class="built_in">free</span>(srcBuf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p> 我们来具体分析一下四次赋值具体发生了什么。首先第一次将 <code>flagUChar</code> 与 <code>7</code> (<code>0b00000111</code>) 进行按位与运算，也就是取其最低 3 位；然后把 <code>srcBuf[srcPos]</code> 与 <code>0xF8</code> (<code>0b11111100</code>) 进行按位与运算，也就是清空其最低 3 位。最后再把两部分结果进行按位或。第二次将 <code>flagUChar</code> 右移了 3 位，再跟 <code>3</code> (<code>0b00000011</code>) 进行按位与，第三次在前面的基础上再右移 2 位，相当于把 <code>flagUChar</code> 总共右移 5 位，与 <code>1</code> (<code>0b00000001</code>) 进行按位与，第四次在前面基础上再右移 1 位，也就是总共右移 6 位，跟 <code>3</code> (<code>0b00000011</code>) 进行按位与。要能够通过 src 图片还原出 flag 图片，那么四个字节的 <code>srcBuf</code> 缓冲区中必须包含一个字节的 <code>flagUChar</code> 的全部信息。</p>
<p> 我在下面列出了 4 次运算中两边各自保留下来的信息位，1 表示信息保留下来，0 表示信息被丢弃，同时左边还表示了 <code>flagUChar</code> 进行移位和按位与运算之后的结果，省略了前面应该补充的 0 。第一次运算中，<code>flagUChar</code> 保留了低 3 位，而 <code>srcBuf</code> 刚好清空了低 3 位，两者进行按位或，那么 <code>flagUChar</code> 最低三位的值就保存在 <code>srcBuf</code> 第一个字节的低三位中。第二次运算，<code>flagUChar</code> 右移三位然后保留最低两位，也就是保留下面标号为 4 和 5 的两位（要注意这两位现在在最低位上），而 <code>srcBuf</code> 刚好清空了最低两位，那么 <code>flagUChar</code> 的 4 和 5 两位的信息就保存在 <code>srcBuf</code> 第二个字节的最低两位中。后面两次以此类推，也都是刚好对应上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8		1 2 3 4 5 6 7 8</span><br><span class="line">----------------	----------------</span><br><span class="line">0 0 0 0 0 1 1 1		1 1 1 1 1 0 0 0</span><br><span class="line">0 0 0 1 1			1 1 1 1 1 1 0 0</span><br><span class="line">0 0 1				1 1 1 1 1 1 1 0</span><br><span class="line">1 1 				1 1 1 1 1 1 0 0</span><br></pre></td></tr></table></figure>

<p> 那么问题就解决了，我们每次从 dst 图片中读取 4 个字节，分别从每个字节中提取 flag 图片一个字节不同位置的值，将它们组合起来，就可以得到 flag 图片了，以下为解密程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* 模仿 bmpencrypt 程序进行类似的文件读取操作 */</span></span><br><span class="line">    FILE *fp_dst = fopen(<span class="string">&quot;dst.bmp&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *fp_flag = fopen(<span class="string">&quot;flag.bmp&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fseek(fp_dst, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="type">long</span> dst_length = ftell(fp_dst);</span><br><span class="line">    fseek(fp_dst, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="type">char</span> *flag_buf = <span class="built_in">malloc</span>(dst_length);</span><br><span class="line">    <span class="type">char</span> *dst_buf = <span class="built_in">malloc</span>(dst_length);</span><br><span class="line">    fread(dst_buf, dst_length, <span class="number">1</span>, fp_dst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次读取 4 个字节，从中提取出 flag 图片一个字节的值。</span></span><br><span class="line"><span class="comment">     * 不知道 flag 图片是多长，但是没有关系 BMP 头里有图片长度的信息，不影响图片显示。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> flag_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> dst_pos = <span class="number">54</span>; dst_pos &lt; dst_length; dst_pos += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">char</span> flag_byte;</span><br><span class="line">        flag_byte = dst_buf[dst_pos] &amp; <span class="number">0b111</span> |</span><br><span class="line">                    (dst_buf[dst_pos + <span class="number">1</span>] &amp; <span class="number">0b11</span>) &lt;&lt; <span class="number">3</span> | </span><br><span class="line">                    (dst_buf[dst_pos + <span class="number">2</span>] &amp; <span class="number">0b1</span>) &lt;&lt; <span class="number">5</span> |</span><br><span class="line">                    (dst_buf[dst_pos + <span class="number">3</span>] &amp; <span class="number">0b11</span>) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">        flag_buf[flag_pos++] = flag_byte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fwrite(flag_buf, flag_pos - <span class="number">1</span>, <span class="number">1</span>, fp_flag);</span><br><span class="line">    <span class="built_in">free</span>(dst_buf);</span><br><span class="line">    <span class="built_in">free</span>(flag_buf);</span><br><span class="line">    fclose(fp_dst);</span><br><span class="line">    fclose(fp_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wind0ws"><a href="#wind0ws" class="headerlink" title="wind0ws"></a>wind0ws</h2><p> 题目给了 <code>loader</code> 和 <code>flag_inside.exe</code> 两个文件，还有这样一段如下的提示，说需要用 <code>loader</code> 程序去加载 <code>flag_inside.exe</code> 程序，然后我们需要去逆向分析 <code>loader</code> 程序，只需要修改一个字节就可以把 flag 打印出来，但是没有说是修改哪个程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage : loader flag_inside.exe</span><br><span class="line"></span><br><span class="line">Reverse the loader to figure out the details of binary file -- &#x27;flag_inside&#x27;</span><br><span class="line"></span><br><span class="line">Modify one byte to get flag printed</span><br><span class="line"></span><br><span class="line">flag&#123;.......&#125;</span><br></pre></td></tr></table></figure>

<p> 其中 <code>loader</code> 是一个 64 位的 ELF 可执行程序，而 <code>flag_inside.exe</code> 显示是一个 <code>MS-DOS</code> 可执行程序。但是在将 <code>flag_inside.exe</code> 拖进 IDA Pro 时它提示这是一个 “packed” 程序，加载之后并没有显示出什么程序信息，可能这是一个加壳的程序，或者这可能压根不是个可执行程序只是伪造了一个文件头，没有关系我们直接以 binary file 加载看看（在 “Load a new file” 窗口选择 “Binary file” 而不是 “MS-DOS executable(EXE)”）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ file loader</span><br><span class="line">loader: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=617291874ad36461d9b439abf71e53a9d4df8fe0, for GNU/Linux 4.4.0, not stripped</span><br><span class="line">$ file flag_inside.exe</span><br><span class="line">flag_inside.exe: MS-DOS executable</span><br></pre></td></tr></table></figure>

<p> 按照提示运行，得到下面的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./loader flag_inside.exe</span><br><span class="line">[Name]: hello.exe</span><br><span class="line">[Info]: compiled by AUx</span><br><span class="line">[Build]: bili:672328094</span><br><span class="line">Hellow world</span><br><span class="line"> </span><br><span class="line">                      _    _ _____ _   _______ _____ _____ </span><br><span class="line"> </span><br><span class="line">                     | |  | |_   _| \ | |  _  \  _  /  ___|</span><br><span class="line"> </span><br><span class="line">                     | |  | | | | |  \| | | | | |/&#x27; \ `--. </span><br><span class="line"> </span><br><span class="line">                     | |/\| | | | | . ` | | | |  /| |`--. \</span><br><span class="line"> </span><br><span class="line">                     \  /\  /_| |_| |\  | |/ /\ |_/ /\__/ /</span><br><span class="line"> </span><br><span class="line">                      \/  \/ \___/\_| \_/___/  \___/\____/ </span><br></pre></td></tr></table></figure>

<p> 首先分析 <code>loader</code> 程序，逻辑还是比较复杂的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  file_hdr *some_hdr; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  entry_struct *entry_struct; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    filename = argv[<span class="number">1</span>];</span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp)</span><br><span class="line">    &#123;</span><br><span class="line">      start_pos = (<span class="type">unsigned</span> <span class="type">int</span>)locate_start(fp);<span class="comment">// integer at offset 60</span></span><br><span class="line">      fseek(fp, start_pos, SEEK_SET);</span><br><span class="line">      some_hdr = (file_hdr *)read_basic_info(fp);<span class="comment">// a struct, size:0x34</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[Name]: %s\n[Info]: %s\n[Build]: %s\n&quot;</span>, some_hdr-&gt;name, some_hdr-&gt;info, some_hdr-&gt;build);</span><br><span class="line">      entry_num = some_hdr-&gt;entry_num;</span><br><span class="line">      <span class="keyword">if</span> (entry_num &lt;= <span class="number">0x10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; entry_num &gt; i; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">          entry_struct = read_entry(fp);        <span class="comment">// another struct with size 0xC, right after basic info</span></span><br><span class="line">          pos = ftell(fp);</span><br><span class="line">          run_section(fp, entry_struct);</span><br><span class="line">          fseek(fp, pos, <span class="number">0</span>);                    <span class="comment">// point to next entry struct</span></span><br><span class="line">          free_hdr(entry_struct);</span><br><span class="line">        &#125;</span><br><span class="line">        free_hdr(some_hdr);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在伪代码中我已经定义好了两个结构体，它们的定义如下。这两个结构体的组成成分根据对后面各个函数的引用得出的，字段名字是根据代码中的字符串以及加上些许猜测得出的。在 IDA Pro 中可以打开 “Local Types” 窗口，按下 insert 键添加自定义的结构体声明，然后右击刚添加的结构体，点击 “Synchorize to idb” ，它就会被同步到 “Structures” 窗口中，然后我们就可以在修改变量类型时使用了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">some_hdr</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> info[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> build[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> entry_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ascii_or_code; <span class="comment">// 1 or 2</span></span><br><span class="line">    <span class="type">char</span> printout; <span class="comment">// 1 or 0</span></span><br><span class="line">    <span class="comment">// 2 bytes&#x27; padding</span></span><br><span class="line">    <span class="type">int</span> data_offset;</span><br><span class="line">    <span class="type">int</span> data_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 程序在打开目标程序（文件）之后，首先调用了 <code>locate_start</code> 函数，从目标文件偏移量 60 处读取了 4 个字节的整数并返回，接着把它传递给 <code>fseek</code> 函数设置指针位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">locate_start</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ptr; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  fseek(fp, <span class="number">60LL</span>, <span class="number">0</span>);</span><br><span class="line">  fread(&amp;ptr, <span class="number">1uLL</span>, <span class="number">4uLL</span>, fp);                  <span class="comment">// read a four bytes&#x27; integer from offset 60</span></span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过在 <code>flag_inside.exe</code> 文件中查看偏移 60 处的值我们发现其定义的指针位置为 <code>0x100</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seg000:0000003B                 db    0</span><br><span class="line">seg000:0000003C start_pos       dd 100h</span><br><span class="line">seg000:00000040                 db  0Eh</span><br><span class="line">seg000:00000041                 db  1Fh</span><br></pre></td></tr></table></figure>

<p> 然后程序调用 <code>read_basic_info</code> 函数从这个偏移量处读取了 <code>0x34</code> 个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">read_basic_info</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *ptr; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ptr = new_hdr(<span class="number">0x34</span>uLL);</span><br><span class="line">  fread(ptr, <span class="number">1uLL</span>, <span class="number">0x34</span>uLL, fp);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">new_hdr</span><span class="params">(<span class="type">size_t</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *s; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  s = <span class="built_in">malloc</span>(a1);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, a1);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在这里简单介绍一下结构体的识别和分析，下面是未修改过的原始伪代码，可以看到 <code>read_basic_info</code> 函数的返回指针保存到了变量 <code>v10</code> ，使用 <code>printf</code> 函数打印出了其指向缓冲区的一些信息，通过 <code>printf</code> 的第一个参数可以知道 <code>v10</code> 、<code>v10 + 16</code> 、<code>v10 + 32</code> 处都是字符串，可以认为它们是字符数组，大小都是 16 ，且三个字段的名字也可以从中得知。在后面的代码中还有一处 <code>printf</code> 打印了变量 <code>off_4</code> 的值，我们可以从中得知它是一个 4 字节的整数类型，且其含义是 entries 的数量，从 <code>flag_inside.exe</code> 中可知其 entries 数量为 4, 这个数据在后面比较关键。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v10 = read_basic_info(stream);</span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">  <span class="string">&quot;[Name]: %s\n[Info]: %s\n[Build]: %s\n&quot;</span>,</span><br><span class="line">  (<span class="type">const</span> <span class="type">char</span> *)v10,</span><br><span class="line">  (<span class="type">const</span> <span class="type">char</span> *)(v10 + <span class="number">16</span>),</span><br><span class="line">  (<span class="type">const</span> <span class="type">char</span> *)(v10 + <span class="number">32</span>));</span><br><span class="line">off_4 = *(_DWORD *)(v10 + <span class="number">48</span>);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error, too many entries : %d\n&quot;</span>, off_4);</span><br></pre></td></tr></table></figure>

<p> 当 entries 数量不大于 16 时，程序接着调用 <code>read_entry</code> 函数，从刚刚 basic info 之后的位置读取 0xC 个字节，保存到 <code>entry_struct</code> 结构体，结构体字段的识别分析不再赘述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; entry_num &gt; i; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  entry_struct = read_entry(fp);        <span class="comment">// another struct with size 0xC, right after basic info</span></span><br><span class="line">  pos = ftell(fp);</span><br><span class="line">  run_section(fp, entry_struct);</span><br><span class="line">  fseek(fp, pos, <span class="number">0</span>);                    <span class="comment">// point to next entry struct</span></span><br><span class="line">  free_hdr(entry_struct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry_struct *__fastcall <span class="title function_">read_entry</span><span class="params">(FILE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  entry_struct *ptr; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ptr = (entry_struct *)new_hdr(<span class="number">0xC</span>uLL);</span><br><span class="line">  fread(ptr, <span class="number">1uLL</span>, <span class="number">0xC</span>uLL, a1);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最终我们来到关键的 <code>run_section</code> 函数，可以看到它根据 <code>entry_struct</code> 结构体的 <code>ascii_or_code</code> 字段决定要执行 <code>run_as_ascii_art</code> 函数还是 <code>run_as_code_section</code> 函数，而且 <code>printout</code> 字段会直接影响是否进行下面这些操作（实际上是控制是否打印出来）。<code>read_section</code> 函数根据结构体中的偏移量和大小将数据读取到 <code>bytes_buf</code> 全局变量中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">run_section</span><span class="params">(FILE *fp, entry_struct *entry_struct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (entry_struct-&gt;printout)</span><br><span class="line">  &#123;</span><br><span class="line">    read_section(fp, entry_struct);</span><br><span class="line">    <span class="keyword">if</span> (entry_struct-&gt;ascii_or_code == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      run_as_ascii_art();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (entry_struct-&gt;ascii_or_code == <span class="number">2</span> )<span class="comment">// currently selected</span></span><br><span class="line">    &#123;</span><br><span class="line">      run_as_code_section();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;Unknown type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __fastcall <span class="title function_">read_section</span><span class="params">(FILE *fp, entry_struct *entry_struct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (entry_struct-&gt;data_size &lt;= <span class="number">0x1000</span>u )</span><br><span class="line">  &#123;</span><br><span class="line">    fseek(fp, (<span class="type">unsigned</span> <span class="type">int</span>)entry_struct-&gt;data_offset, SEEK_SET);</span><br><span class="line">    fread(bytes_buf, <span class="number">1uLL</span>, <span class="number">0x1000</span>uLL, fp);</span><br><span class="line">  &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其中 <code>run_as_ascii_art</code> 函数只是简单的将读入的数据作为字符串打印出来，控制了一下换行。<code>run_as_code_section</code> 函数逻辑很复杂，看起来像是个加密或者解密算法，但不需要分析所以没有贴出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">run_as_ascii_art</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">signed</span> __int8 c; <span class="comment">// [rsp+7h] [rbp-9h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">4095</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = bytes_buf[i];</span><br><span class="line">    c = bytes_buf[i];</span><br><span class="line">    <span class="keyword">if</span> (!c)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">    result = i % <span class="number">61</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(i % <span class="number">61</span>) )</span><br><span class="line">      result = <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 从 <code>flag_inside.exe</code> 文件对应偏移位置我们可以看到 4 个 entries 各字段的值（此处可以结合结构体和数组进行定义）。分别到四个 entries 对应的 <code>data_offset</code> 查看数据内容，entry 3 和 entry 4 分别是一个组成了类似佛像和一个组成 Windows 字母的字符画，根据其 <code>ascii_or_code</code> 字段值得知它们通过 <code>run_as_ascii_art</code> 函数输出，但是 entry 3 的 <code>printout</code> 字段为 0 ，所以实际不会被输出，这与前面实际运行结果是一致的。那么如果 entry 1 对应的是在字符画之前输出的 “Hellow world” 字符串，那么 entry 2 可能就是我们要的 flag 了。所以最初提示的修改一个字节，可能就是需要我们修改 entry 2 的 printout 字节为 1 ，这样 entry 2 的数据就能被 <code>run_as_code_section</code> 函数解密并打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seg000:00000134                 db 2                    ; ascii_or_code ; entry 1 </span><br><span class="line">seg000:00000134                 db 1                    ; printout</span><br><span class="line">seg000:00000134                 db 2 dup(0)</span><br><span class="line">seg000:00000134                 dd 1000h                ; data_offset</span><br><span class="line">seg000:00000134                 dd 1000h                ; data_size</span><br><span class="line">seg000:00000140                 db 2                    ; ascii_or_code ; entry 2</span><br><span class="line">seg000:00000140                 db 0                    ; printout</span><br><span class="line">seg000:00000140                 db 2 dup(0)</span><br><span class="line">seg000:00000140                 dd 2000h                ; data_offset</span><br><span class="line">seg000:00000140                 dd 1000h                ; data_size</span><br><span class="line">seg000:0000014C                 db 1                    ; ascii_or_code ; entry 3</span><br><span class="line">seg000:0000014C                 db 0                    ; printout</span><br><span class="line">seg000:0000014C                 db 0D8h, 24h</span><br><span class="line">seg000:0000014C                 dd 3000h                ; data_offset</span><br><span class="line">seg000:0000014C                 dd 1000h                ; data_size</span><br><span class="line">seg000:00000158                 db 1                    ; ascii_or_code ; entry 4</span><br><span class="line">seg000:00000158                 db 1                    ; printout</span><br><span class="line">seg000:00000158                 db 2 dup(0)</span><br><span class="line">seg000:00000158                 dd 4000h                ; data_offset</span><br><span class="line">seg000:00000158                 dd 1000h                ; data_size</span><br></pre></td></tr></table></figure>

<p> 修改字节操作可以使用 IDA Pro 提供的 “Edit” -&gt; “Patch program” -&gt; “Change byte” ，但是似乎有一些问题，我改过来改回去最终有一部分修改并没有生效，最后直接用 <code>hexedit</code> 工具，定位到相应的偏移量直接进行修改。修改后再次运行，flag 被打印出来。</p>
<p>……所以这题跟 Windows 没有半点关系啊哈？</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Write-up | NeSE 丙组 202202</p><p><a href="https://www.nuke666.cn/2022/02/Write-up-for-NeSE-202202/">https://www.nuke666.cn/2022/02/Write-up-for-NeSE-202202/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChinaNuke</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-02-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/02/Install-arch-linux/"><span class="level-item">Arch Linux 安装步骤记录</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.7.2/gitalk.css"><script src="https://cdnjs.loli.net/ajax/libs/gitalk/1.7.2/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "7d83ff367e1bf9d00cb8b9781253429c",
            repo: "chinanuke.github.io",
            owner: "ChinaNuke",
            clientID: "3f7fe9cdb9780bcf2eb8",
            clientSecret: "fa11d11f3291e3e92da34995cef1cea1eca4f60e",
            admin: ["ChinaNuke"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            proxy: "https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen is-3-fullhd  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="ChinaNuke"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ChinaNuke</p><p class="is-size-6 is-block">一个入门小 pwn 手</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中科院信息工程研究所</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/chinanuke" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/chinanuke"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="Mailto:chinanuke@nuke666.cn"><i class="far fa-envelope"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#babybmp"><span class="level-left"><span class="level-item">1</span><span class="level-item">babybmp</span></span></a></li><li><a class="level is-mobile" href="#wind0ws"><span class="level-left"><span class="level-item">2</span><span class="level-item">wind0ws</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">友情链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://huuhghhgyg.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Huuhghhgyg</span></span><span class="level-right"><span class="level-item tag">huuhghhgyg.github.io</span></span></a></li><li><a class="level is-mobile" href="http://www.f0und.icu/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">F0und</span></span><span class="level-right"><span class="level-item tag">www.f0und.icu</span></span></a></li><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99/"><span class="level-start"><span class="level-item">网站</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-12T10:14:41.000Z">2022-02-12</time></p><p class="title"><a href="/2022/02/Write-up-for-NeSE-202202/">Write-up | NeSE 丙组 202202</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-06T03:45:12.000Z">2022-02-06</time></p><p class="title"><a href="/2022/02/Install-arch-linux/">Arch Linux 安装步骤记录</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-26T07:03:36.000Z">2021-11-26</time></p><p class="title"><a href="/2021/11/Some-useful-cheat-sheets/">一些有用的 Cheat Sheets</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-11T06:16:58.000Z">2021-08-11</time></p><p class="title"><a href="/2021/08/Write-up-for-NeSE-monthly-contest-in-July/">Write-up | NeSE 丙组 7 月月赛</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-06T12:19:05.000Z">2021-08-06</time></p><p class="title"><a href="/2021/08/Specify-switch-statement-in-IDA-Pro/">在 IDA Pro 中恢复 switch 语句</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"><span class="tag">使用技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"><span class="tag">网络设置</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">ChinaNuke的博客</a><p class="is-size-7"><span>&copy; 2022 ChinaNuke</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ChinaNuke/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><a href="http://beian.miit.gov.cn/" target="_blank" style="color:inherit">京ICP备2021027097号</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="托管于 GitHub Pages" href="https://github.com/ChinaNuke/ChinaNuke.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶部" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>