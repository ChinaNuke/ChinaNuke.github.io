<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>记一次 QNAP 漏洞发现和分析 - 就我还用小米6了！</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="就我还用小米6了！"><meta name="msapplication-TileImage" content="/img/myfavicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="就我还用小米6了！"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文记录最近一次QNAP设备上的漏洞分析过程，从发现漏洞到最终尝试利用漏洞，结论是这个漏洞没有什么利用价值，白整。但作为第一次较为完整的走完挖洞流程，还是值得记录一下的。 漏洞发现漏洞是使用师兄的 IoT_Fuzzer 对 NAS 进行 Fuzz 时发现的，Fuzzer 通过对请求中参数的值进行变异来生成 payloads 。在对 sysRequest.cgi 构造的 payloads 中，有一个"><meta property="og:type" content="blog"><meta property="og:title" content="记一次 QNAP 漏洞发现和分析"><meta property="og:url" content="https://www.nuke666.cn/2021/01/analyze-an-overflow-vulnerability-on-qnap/"><meta property="og:site_name" content="就我还用小米6了！"><meta property="og:description" content="本文记录最近一次QNAP设备上的漏洞分析过程，从发现漏洞到最终尝试利用漏洞，结论是这个漏洞没有什么利用价值，白整。但作为第一次较为完整的走完挖洞流程，还是值得记录一下的。 漏洞发现漏洞是使用师兄的 IoT_Fuzzer 对 NAS 进行 Fuzz 时发现的，Fuzzer 通过对请求中参数的值进行变异来生成 payloads 。在对 sysRequest.cgi 构造的 payloads 中，有一个"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.nuke666.cn/posts/2021/202101_fuzzer_result.png"><meta property="og:image" content="https://images.nuke666.cn/posts/2021/202101_burpsuite_set_intercept_rule.png"><meta property="og:image" content="https://images.nuke666.cn/posts/2021/202101_qnap_web_settings.png"><meta property="og:image" content="https://images.nuke666.cn/posts/2021/202101_burpsuite_post_data.png"><meta property="og:image" content="https://images.nuke666.cn/posts/2021/202101_qnap_web_crashed.png"><meta property="og:image" content="https://images.nuke666.cn/posts/2021/202101_ida_xrefs_to_fork.png"><meta property="article:published_time" content="2021-01-25T09:35:44.000Z"><meta property="article:modified_time" content="2021-01-25T10:07:46.652Z"><meta property="article:author" content="ChinaNuke"><meta property="article:tag" content="QNAP"><meta property="article:tag" content="漏洞"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://images.nuke666.cn/posts/2021/202101_fuzzer_result.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.nuke666.cn/2021/01/analyze-an-overflow-vulnerability-on-qnap/"},"headline":"就我还用小米6了！","image":["https://images.nuke666.cn/posts/2021/202101_fuzzer_result.png","https://images.nuke666.cn/posts/2021/202101_burpsuite_set_intercept_rule.png","https://images.nuke666.cn/posts/2021/202101_qnap_web_settings.png","https://images.nuke666.cn/posts/2021/202101_burpsuite_post_data.png","https://images.nuke666.cn/posts/2021/202101_qnap_web_crashed.png","https://images.nuke666.cn/posts/2021/202101_ida_xrefs_to_fork.png"],"datePublished":"2021-01-25T09:35:44.000Z","dateModified":"2021-01-25T10:07:46.652Z","author":{"@type":"Person","name":"ChinaNuke"},"description":"本文记录最近一次QNAP设备上的漏洞分析过程，从发现漏洞到最终尝试利用漏洞，结论是这个漏洞没有什么利用价值，白整。但作为第一次较为完整的走完挖洞流程，还是值得记录一下的。 漏洞发现漏洞是使用师兄的 IoT_Fuzzer 对 NAS 进行 Fuzz 时发现的，Fuzzer 通过对请求中参数的值进行变异来生成 payloads 。在对 sysRequest.cgi 构造的 payloads 中，有一个"}</script><link rel="canonical" href="https://www.nuke666.cn/2021/01/analyze-an-overflow-vulnerability-on-qnap/"><link rel="icon" href="/img/myfavicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">就我还用小米6了！</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="我的 GitHub 主页" href="https://github.com/ChinaNuke"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-25T09:35:44.000Z" title="2021-01-25T09:35:44.000Z">2021-01-25</time>发表</span><span class="level-item"><time dateTime="2021-01-25T10:07:46.652Z" title="2021-01-25T10:07:46.652Z">2021-01-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%AE%89%E5%85%A8/">安全</a></span><span class="level-item">33 分钟读完 (大约4887个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">记一次 QNAP 漏洞发现和分析</h1><div class="content"><p>本文记录最近一次 QNAP 设备上的漏洞分析过程，从发现漏洞到最终尝试利用漏洞，结论是这个漏洞没有什么利用价值，白整。但作为第一次较为完整的走完挖洞流程，还是值得记录一下的。</p>
<h2 id="漏洞发现"><a href="# 漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现 </h2><p> 漏洞是使用师兄的 IoT_Fuzzer 对 NAS 进行 Fuzz 时发现的，Fuzzer 通过对请求中参数的值进行变异来生成 payloads 。在对 <code>sysRequest.cgi</code> 构造的 payloads 中，有一个对 POST 请求中的 <code>serv_name</code> 字段进行变异，提交一个超长的字段值，服务器返回状态码为 500，疑似发生异常。（实际上后来发现，找到这个漏洞纯属偶然，因为就算提交一个正常的 <code>serv_name</code> 同样也会返回 500，应该是 cgi 脚本的问题）</p>
<img src="https://images.nuke666.cn/posts/2021/202101_fuzzer_result.png" alt="Fuzzer 发现可能的漏洞"  class="box mx-auto px-0 py-0" width="400" />

<a id="more"></a>

<p>启动 Burpsuite，设置拦截规则，对含有 <code>serv_name</code> 字段的请求进行拦截。登录 Web，打开控制台，修改“服务器名称”字段（正常值），提交修改，请求被 Burpsuite 拦截到。修改请求数据中的 <code>serv_name</code> 字段为超长值，foward 请求。</p>
<img src="https://images.nuke666.cn/posts/2021/202101_burpsuite_set_intercept_rule.png" alt="为 Burpsuite 设置拦截规则" class="box mx-auto px-0 py-0" width="400" />

<img src="https://images.nuke666.cn/posts/2021/202101_qnap_web_settings.png" alt="在 Web 控制台中修改服务器名称"  class="box mx-auto px-0 py-0" width="400" />

<img src="https://images.nuke666.cn/posts/2021/202101_burpsuite_post_data.png" alt="使用 Burpsuite 改包验证" class="box px-0 py-0 ml-auto mr-auto" width="400" />

<p>等待一段时间后，服务器返回了 500 状态码。此时刷新 Web 页面，页面中只有蓝色背景，无法再正常加载出页面。若在此时重启 NAS 设备，则启动完成后系统状态指示灯为红色，通过 ssh 连接查看，发现设备没有正常挂载磁盘。此时基本可以确认有漏洞存在。</p>
<img src="https://images.nuke666.cn/posts/2021/202101_qnap_web_crashed.png" alt="Web 页面崩溃"  class="box mx-auto px-0 py-0" width="400" />





<h2 id="漏洞分析"><a href="# 漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析 </h2><h3 id="提取文件系统"><a href="# 提取文件系统" class="headerlink" title="提取文件系统"></a> 提取文件系统 </h3><p> 下载 QTS 4.5.1 固件 <code>TS-X53D_20201123-4.5.1.1495.zip</code>，解压得到一个 img 文件，使用 <code>file</code> 命令查看这个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file TS-X53D_20201123-4.5.1.1495.img</span><br><span class="line">TS-X53D_20201123-4.5.1.1495.img: data</span><br></pre></td></tr></table></figure>
<p>使用 <code>binwalk</code> 分析这个文件，在结果最后一行可以看到固件使用某种方式加密了，我们无法直接得到固件的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ binwalk TS-X53D_20201123-4.5.1.1495.img </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">106037306     0x652003A       MySQL MISAM index file Version 3</span><br><span class="line">121452831     0x73D391F       MySQL ISAM compressed data file Version 11</span><br><span class="line">126212996     0x785DB84       Cisco IOS microcode, <span class="keyword">for</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">174056598     0xA5FE496       MySQL MISAM compressed data file Version 8</span><br><span class="line">186982295     0xB251F97       MySQL MISAM index file Version 6</span><br><span class="line">209652627     0xC7F0B93       QNAP encrypted firmware footer , model: TS-X53D , version: 4.5.1 , date: 20201123</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在网上搜寻如何解密 <code>QNAP</code> 固件时，发现了 <code>StackExchange</code> 上有这么一篇 <a target="_blank" rel="noopener" href="https://reverseengineering.stackexchange.com/questions/2704/firmware-analysis-and-file-system-extraction"> 问答</a>，在被采纳的回答中，详细介绍了他通过系统恢复镜像（Full system recovery image）入手，在镜像中找到解密程序和解密密钥的过程。回答末尾给出了用 C 写的加解密算法程序 <a target="_blank" rel="noopener" href="https://pastebin.com/KHbX85nG">pc1.c</a>。下载编译 <code>pc1</code> ，使用密钥 <code>QNAPNASVERSION4</code> ，即可对固件进行解密。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o pc1 pc1.c</span><br><span class="line">$ ./pc1</span><br><span class="line">Usage: ./pc1 e|d <span class="string">&quot;key&quot;</span> sourcefile targetfile</span><br><span class="line">./pc1 d QNAPNASVERSION4 TS-219_3.5.0_Build0816.img TS-219_3.5.0_Build0816.img.tgz</span><br><span class="line">./pc1 e QNAPNASVERSION4 TS-219_3.5.0_Build0816.img.tgz TS-219_3.5.0_Build0816.img</span><br><span class="line">$ ./pc1 d QNAPNASVERSION4 TS-X53D_20201123-4.5.1.1495.img TS-X53D_20201123-4.5.1.1495_decrypted.tar.gz</span><br><span class="line">$ ll -d TS-X53D*</span><br><span class="line">-rw-rw-r-- 1 iie iie 209652627 12 月 27 12:14 TS-X53D_20201123-4.5.1.1495_decrypted.tar.gz</span><br><span class="line">-rw-r--r-- 1 iie iie 209652701 11 月 23 09:52 TS-X53D_20201123-4.5.1.1495.img</span><br><span class="line">$ mkdir TS-X53D_20201123-4.5.1.1495_decrypted</span><br><span class="line">$ tar xvf TS-X53D_20201123-4.5.1.1495_decrypted.tar.gz -C TS-X53D_20201123-4.5.1.1495_decrypted</span><br><span class="line">$ ls TS-X53D_20201123-4.5.1.1495_decrypted</span><br><span class="line">1062xfwdl               fw_info.conf        rootfs2.bz.cksum</span><br><span class="line">1062xfwdl_lib64.tar.gz  initrd.boot         rootfs2.bz.sign</span><br><span class="line">107FWTools              initrd.boot.cksum   rootfs_ext.tgz</span><br><span class="line">140415_03_4F_01.bin     initrd.boot.sign    rootfs_ext.tgz.cksum</span><br><span class="line">asm1062.ROM             IS_64BITS           rootfs_ext.tgz.sign</span><br><span class="line">asm1074.conf            IS_STORAGE_V2       sas_fw</span><br><span class="line">asmthub.ko              libcrypto.so.1.0.0  update</span><br><span class="line">boot                    libssl.so.1.0.0     update_asm1062.conf</span><br><span class="line">bzImage                 Q04WE009.BIN        update_asm1062.sh</span><br><span class="line">bzImage.cksum           qpkg.tar            update_ec.conf</span><br><span class="line">bzImage.sign            qpkg.tar.cksum      update_ec.sh</span><br><span class="line">config                  qpkg.tar.sign       update_img.sh</span><br><span class="line">ec_force_boot           QZ29E003.BIN        update_pic.conf</span><br><span class="line">find_ASM107             QZ53E104.BIN        update_pic.sh</span><br><span class="line">fw_info                 rootfs2.bz</span><br></pre></td></tr></table></figure>
<p>根据这篇回答中对固件内容的分析，我们可以得知：</p>
<ul>
<li>initrd 是使得操作系统运行的初始根文件系统</li>
<li>rootfs2.bz 是含有 /home, /lib 和 /usr 等目录的压缩包</li>
<li>rootfs_ext.tgz 是含有 /opt/source 目录的另一个 ext2 文件系统的压缩包</li>
</ul>
<p>对这三个包分别进行解压提取并组合，便可以得到整个文件系统。而我们需要分析的<code>sysRequest.cgi</code>，在 /home 目录下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls all</span><br><span class="line">bin  etc   init  lib64    lost+found  opt      proc  run.sh  share  usr</span><br><span class="line">dev  home  lib   linuxrc  mnt         php.ini  root  sbin    tmp    var</span><br><span class="line">$ find ./all -name sysRequest.cgi</span><br><span class="line">./all/home/httpd/cgi-bin/sys/sysRequest.cgi</span><br></pre></td></tr></table></figure>
<h3 id="漏洞成因分析"><a href="# 漏洞成因分析" class="headerlink" title="漏洞成因分析"></a>漏洞成因分析 </h3><p> 既然拿到了 cgi 程序，那先用 IDA Pro 进行一波静态分析，对整个程序的执行流程有个了解。使用 IDA 打开 sysRequest.cgi 程序，在 Functions Window 中找到 main 函数，利用内置的 HexRays 插件，按下 F5 对 main 函数进行反编译得到伪代码，在第 130 行左右发现这样的内容.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)auth_get_session(v21, <span class="number">1LL</span>, &amp;unk_67F7C0) &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)auth_get_session(v21, <span class="number">2LL</span>, &amp;unk_67F7C0)</span><br><span class="line">  || !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)User_Belongs_To_Group(src, <span class="string">&quot;administrators&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  sub_412480();</span><br><span class="line">  sub_412FE0(<span class="number">0LL</span>);</span><br><span class="line">  sub_4124C0();</span><br><span class="line">  <span class="keyword">goto</span> LABEL_101;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 语句的条件中调用了两个函数： <code>auth_get_session</code> 和 <code>User_Belongs_To_Group</code> 。如果两次调用 <code>auth_get_session</code> 返回值都是 1，或者 <code>User_Belongs_To_Group</code> 返回值是 0（或者说 false），那么执行一些调用后跳转到 LABEL_101，即进行一些必要的处理之后退出程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LABEL_101:</span><br><span class="line">        <span class="keyword">if</span> (v3)</span><br><span class="line">          CGI_Free_Input(v3);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>从这里我们大致可以知道，要触发这个程序中存在的漏洞，必须是已登录用户且登录用户必须属于 administrators 用户组。</p>
<p>通过 ssh 连接 NAS，发现 <code>dmesg</code> 命令显示的信息中记录下了程序崩溃的一些信息，信息中包含了崩溃时的 ip（0x7f9ca6092bff）、崩溃所在的库（libc-2.21.so）以及这个库的起始地址（0x7f9ca602a000）等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[~] # dmesg | tail</span><br><span class="line">...</span><br><span class="line">[7365.850787] traps: sysRequest.cgi[24316] general protection ip:7f9ca6092bff sp:7ffc0a64ca80 error:0 in libc-2.21.so[7f9ca602a000+199000]</span><br></pre></td></tr></table></figure>
<p>找到这个 libc，计算出该位置在库中的实际偏移，查看该位置处的代码，可以看到调用了一个 strlen，从这里我们看不出什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name libc-2.21.so</span><br><span class="line">.&#x2F;lib&#x2F;libc-2.21.so</span><br><span class="line">$ gdb .&#x2F;lib&#x2F;libc-2.21.so</span><br><span class="line">(gdb) p&#x2F;x 0x7f9ca6092bff - 0x7f9ca602a000</span><br><span class="line">$1 &#x3D; 0x68bff</span><br><span class="line">(gdb) x&#x2F;10i 0x68bf0</span><br><span class="line">   0x68bf0 &lt;fputs&gt;:	push   %r12</span><br><span class="line">   0x68bf2 &lt;fputs+2&gt;:	push   %rbp</span><br><span class="line">   0x68bf3 &lt;fputs+3&gt;:	mov    %rdi,%rbp</span><br><span class="line">   0x68bf6 &lt;fputs+6&gt;:	push   %rbx</span><br><span class="line">   0x68bf7 &lt;fputs+7&gt;:	mov    %rsi,%rbx</span><br><span class="line">   0x68bfa &lt;fputs+10&gt;:	callq  0x80240 &lt;strlen&gt;</span><br><span class="line">   0x68bff &lt;fputs+15&gt;:	mov    (%rbx),%r8d</span><br><span class="line">   0x68c02 &lt;fputs+18&gt;:	mov    %rax,%r12</span><br><span class="line">   0x68c05 &lt;fputs+21&gt;:	and    $0x8000,%r8d</span><br><span class="line">   0x68c0c &lt;fputs+28&gt;:	jne    0x68c71 &lt;fputs+129&gt;</span><br></pre></td></tr></table></figure>
<p>接下来进行动态调试。最初使用 IDA + QEMU 的组合对 sysRequest.cgi 进行调试，但是始终没有复现出程序崩溃，可能是因为传入的参数与实际参数有差异。</p>
<p>因为可以通过 ssh 直接进入 NAS，师兄建议用 gdbserver 直接 attach 到运行的 httpd 进程上，跟踪子进程来进行调试。httpd 接收到请求时，会 fork 出一个子进程，然后去调用对应的 cgi 程序去处理请求。在 gdb 中，可以通过 ``set follow-fork-mode child` 命令设置在遇到 fork 时调试子进程而不是调试父进程，这样我们就可以通过 httpd 进程来进入到 sysRequest.cgi 进程中。</p>
<p>需要注意的是，IDA 内置的 gdb 是不支持调试子进程的，因此我们只能用 IDA 去做静态分析，再配合命令行的 gdb 去进行动态调试。</p>
<p>用 <code>ps</code> 命令查看一下相关的进程，可以看到 NAS 并没有使用原生的 httpd 服务，而是使用了更轻量的 thttpd，诶？那个 Qthttpd 是个什么玩意？我要 attach 到哪个进程上面？</p>
<p>NAS 上的 ps 命令来自 busybox，从输出结果可以看出它只显示了进程 id，并没有显示出父进程 id，这样我们不好看出进程之间的关系。看一下<code>ps --help</code>，几乎是啥参数也不支持，白瞎。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[~] # ps | grep httpd</span><br><span class="line"> 6802 admin      1664 S   &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;_thttpd_ -p 58080 -nor -nos -u admin -d &#x2F;home&#x2F;httpd -c **.* -h 127.0.0.1 -i &#x2F;var&#x2F;lock&#x2F;._thttpd_.pid</span><br><span class="line"> 6806 admin       912 S   grep httpd</span><br><span class="line">11490 admin      5100 S   &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;Qthttpd -p 80 -nor -nos -u admin -d &#x2F;home&#x2F;Qhttpd -c **.*</span><br><span class="line">12323 admin      5336 S   &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;_thttpd_ -p 58080 -nor -nos -u admin -d &#x2F;home&#x2F;httpd -c **.* -h 127.0.0.1 -i &#x2F;var&#x2F;lock&#x2F;._thttpd_.pid</span><br><span class="line">13111 httpdusr   4192 S   &#x2F;sbin&#x2F;lpb_scheduler -d</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[~] # ps --help</span><br><span class="line">BusyBox v1.24.1 (2020-11-23 03:01:36 CST) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: ps [-o COL1,COL2&#x3D;HEADER] [-T]</span><br><span class="line"></span><br><span class="line">Show list of processes</span><br><span class="line"></span><br><span class="line">        -o COL1,COL2&#x3D;HEADER     Select columns for display</span><br><span class="line">        -T                      Show threads</span><br><span class="line"></span><br><span class="line">QNAP Options:</span><br><span class="line">        --columns N</span><br></pre></td></tr></table></figure>
<p>因此我下载了 procps 源码，在 Ubuntu x64 上自己编译了完整的 <code>ps</code> 程序（NAS 也是 x64），拷贝到 NAS 上的 <code>/usr/local/bin</code> 目录，为了不对系统中原有的可能依赖于 ps 命令的脚本造成影响，我将自己编译的命名为<code>myps</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[~] # cp pscommand &#x2F;usr&#x2F;local&#x2F;bin&#x2F;myps</span><br><span class="line">[~] # myps -ef | grep httpd</span><br><span class="line">admin    11490     1  0 03:07 ?        00:00:00 &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;Qthttpd -p 80 -nor -nos -u admin -d &#x2F;home&#x2F;Qhttpd -c **.*</span><br><span class="line">admin    12323     1  0 03:07 ?        00:00:01 &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;_thttpd_ -p 58080 -nor -nos -u admin -d &#x2F;home&#x2F;httpd -c **.* -h 127.0.0.1 -i &#x2F;var&#x2F;lock&#x2F;._thttpd_.pid</span><br><span class="line">httpdusr 13111     1  0 03:07 ?        00:00:00 &#x2F;sbin&#x2F;lpb_scheduler -d</span><br><span class="line">admin    17004 15541  0 05:39 pts&#x2F;4    00:00:00 grep httpd</span><br></pre></td></tr></table></figure>
<p>需要注意，要把 pscommand 程序编译成静态的，在 configure 时添加如下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;configure --disable-shared LDFLAGS&#x3D;--static</span><br></pre></td></tr></table></figure>
<p>那么 Qthttpd 是啥呢？Google 了一番发现，Qthttpd 是用来给用户自定义 Web 服务的，从它开放的 80 端口也可以看出这一点。而对于系统 Web 页面，则是设定在 5000 端口上，那么为什么 thttpd 进程启动时是指定的 58080 端口呢？查一下 5000 端口，发现在监听的是 apache_proxy 进程，大致可以推断请求先发送到 apache_proxy 进程，然后由它作为代理再转发到 thttpd 进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[~] # netstat -tunlp | grep 5000                                                  </span><br><span class="line">tcp        0      0 :::5000                 :::*                    LISTEN      5619&#x2F;apache_proxy</span><br></pre></td></tr></table></figure>
<p>既然跟系统 Web 无关，为了避免它对后续调试造成干扰，直接关掉它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;Qthttpd.sh stop</span><br></pre></td></tr></table></figure>
<p>此外，我们还要干掉 daemon_mgr 这个进程。在实际调试过程中发现，调试一小会儿之后程序居然自己挂掉了……发生肾磨石了？经过分析发现，daemon_mgr 这个程序会定期向本地的 thttpd 进程发送一个 get 请求，那么显然是它检测到请求没有响应，丢弃了原先的进程，新开了一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall daemon_mgr</span><br></pre></td></tr></table></figure>
<p>接下来，我们便可以直接用 gdbserver 来 attach 到唯一的一个 thttpd 进程上了。为了避免去解决麻烦的库依赖问题，我们同样使用 <a target="_blank" rel="noopener" href="https://github.com/akpotter/embedded-toolkit/tree/master/prebuilt_static_bins/gdbserver"> 静态编译的 gdbserver</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[~] # .&#x2F;gdbserver-7.12-x86_64-sysv --attach :12345 12323</span><br></pre></td></tr></table></figure>
<p>至此我们可以快快乐乐的进行附加调试了。</p>
<p>首先再理一下动态调试的目的：attach 到 thttpd 进程上，手动触发对 sysRequest.cgi 的请求，提供一个超长的 <code>serv_name</code> 字段，找出从哪里 fork 的子进程，然后进入到动态运行的 sysRequest.cgi 中，进而捕获程序崩溃时的现场。</p>
<p>使用 IDA 静态分析 thttpd 程序，查找 fork 函数的引用，总共有三处。打断点测试后，确认进入 sysRequest.cgi 子程序的是地址为 <code>0x410a80</code> 处的 fork。</p>
<img src="https://images.nuke666.cn/posts/2021/202101_ida_xrefs_to_fork.png" alt="thttpd 程序中有三处对 fork 函数的引用"  class="box mx-auto px-0 py-0" width="400" />

<p>使用 gdb 调试 thttpd 程序，通过 <code>target remote</code> 连接到运行在 NAS 设备上的 gdbserver，确认 <code>0x410a80</code> 地址处的内容，并在该处施加断点，然后继续运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gdb _thttpd_</span><br><span class="line">(gdb) target remote 192.168.0.141:12345</span><br><span class="line">Remote debugging using 192.168.0.141:12345</span><br><span class="line">Reading &#x2F;lib&#x2F;libcrypt.so.1 from remote target...</span><br><span class="line">...</span><br><span class="line">(gdb) x&#x2F;i 0x410a80</span><br><span class="line">   0x410a80:    callq  0x402ef0 &lt;fork@plt&gt;</span><br><span class="line">(gdb) b *0x410a80</span><br><span class="line">Breakpoint 1 at 0x410a80</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure>
<p>接着我们使用 Burpsuite 的 Repeater 手动提交请求，将 <code>serv_name</code> 字段设置为 DDDDD……（好多好多 D），然后提交请求。最好是在登录 Web 后关掉浏览器，之所以选择这样而不是直接通过 Web 页面提交请求然后 Burpsuite 抓包再修改，是因为 Web 页面打开的时候它也会自动去提交一些请求，影响我们观测。</p>
<p>命中 fork 调用处的断点后，我们设置调试子进程，然后再运行一个<code>ni</code>，可以看到 gdb 从父进程上 detach 了，切换到了子进程。之所以要在命中 fork 断点后才开启调试子进程，是因为从前面的分析中我们发现总共有三处对 fork 的调用，一开始就开启调试子进程可能会与我们的预期不符。</p>
<p>进入子进程之后，我们也要再设置一下调试父进程（现在的子进程就是父进程了），因为 sysRequest.cgi 中也有多处对 fork 的调用，我们并不想研究那些无关的调用。接着用 <code>catch exec</code> 来捕获对 exec 的调用，它会自动进入 exec 所调用的程序，也就是 sysRequest.cgi。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, 0x0000000000410a80 in ?? ()</span><br><span class="line">(gdb) set follow-fork-mode child</span><br><span class="line">(gdb) ni</span><br><span class="line">[Attaching after Thread 14294.14294 fork to child Thread 29226.29226]</span><br><span class="line">[New inferior 2 (process 29226)]</span><br><span class="line">[Detaching after fork from parent process 14294]</span><br><span class="line">[Inferior 1 (process 14294) detached]</span><br><span class="line">[Switching to Thread 29226.29226]</span><br><span class="line">0x0000000000410a85 in ?? ()</span><br><span class="line">(gdb) set follow-fork-mode parent</span><br><span class="line">(gdb) catch exec</span><br><span class="line">Catchpoint 2 (exec)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Detaching after fork from child process 29654]</span><br><span class="line">[Detaching after fork from child process 29655]</span><br><span class="line">process 29226 is executing new program: &#x2F;home&#x2F;httpd&#x2F;cgi-bin&#x2F;sys&#x2F;sysRequest.cgi</span><br><span class="line">Reading &#x2F;home&#x2F;httpd&#x2F;cgi-bin&#x2F;sys&#x2F;sysRequest.cgi from remote target...</span><br><span class="line">...</span><br><span class="line">Thread 2.1 &quot;sysRequest.cgi&quot; hit Catchpoint 2 (exec&#39;d &#x2F;home&#x2F;httpd&#x2F;cgi-bin&#x2F;sys&#x2F;sysRequest.cgi), 0x00007fbdf681bc40 in ?? () from target:&#x2F;lib64&#x2F;ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure>
<p>为了确认一下我们确实进入到了 sysRequest.cgi 进程中，我们在 <code>0x4171ab</code> 处打一个断点，这是程序中开始获取参数的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x4171ab</span><br><span class="line">Breakpoint 3 at 0x4171ab</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">...</span><br><span class="line">Thread 2.1 &quot;sysRequest.cgi&quot; hit Breakpoint 3, 0x00000000004171ab in ?? ()</span><br><span class="line">(gdb) x&#x2F;i $pc</span><br><span class="line">&#x3D;&gt; 0x4171ab:    callq  0x40dca0 &lt;CGI_Get_Input@plt&gt;</span><br></pre></td></tr></table></figure>
<p>继续执行，几秒钟之后我们看到发生了 Segmentation fault，在 libc 中。输入 <code>bt</code> 查看栈帧，可以看到溢出发生了，下面的栈帧全部被 0x44 填充，也就是字母 D。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">...</span><br><span class="line">[Detaching after fork from child process 4421]</span><br><span class="line"></span><br><span class="line">Thread 2.1 &quot;sysRequest.cgi&quot; received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00007f7d5b62fbff in fputs () from target:&#x2F;lib&#x2F;libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007f7d5b62fbff in fputs () from target:&#x2F;lib&#x2F;libc.so.6</span><br><span class="line">#1  0x00007f7d5edcbf93 in Modify_Hosts () from target:&#x2F;usr&#x2F;lib&#x2F;libuLinux_config.so.0</span><br><span class="line">#2  0x4444444444444444 in ?? ()</span><br><span class="line">#3  0x4444444444444444 in ?? ()</span><br><span class="line">#4  0x4444444444444444 in ?? ()</span><br><span class="line">#5  0x4444444444444444 in ?? ()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>虽然大部分栈帧指针都被覆盖掉了，我们可以看到在 #1 处的 Modify_Hosts()函数，那么我们接下来去分析一下这个函数。反编译这个函数得到伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">Modify_Hosts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *server_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *host_file; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">272</span>]; <span class="comment">// [rsp+10h] [rbp-1A0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">35</span>]; <span class="comment">// [rsp+120h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> address[<span class="number">93</span>]; <span class="comment">// [rsp+143h] [rbp-6Dh] BYREF</span></span><br><span class="line">  FILE *tmp_file; <span class="comment">// [rsp+1A0h] [rbp-10h]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+1A8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  host_file = fopen64(<span class="string">&quot;/etc/hosts&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  stream = host_file;</span><br><span class="line">  <span class="keyword">if</span> (host_file)</span><br><span class="line">  &#123;</span><br><span class="line">    tmp_file = fopen64(<span class="string">&quot;/tmp/hosts.tmp&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (tmp_file)</span><br><span class="line">    &#123;</span><br><span class="line">      NIC_Get_Info(v4, <span class="number">2LL</span>);</span><br><span class="line">      <span class="keyword">while</span> (!feof(stream) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (fgets(s, <span class="number">257</span>, stream) )            <span class="comment">// read one line at a time</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">strstr</span>(s, address) )</span><br><span class="line">            <span class="built_in">sprintf</span>(s, <span class="string">&quot;%s\t\t%s\t\t%s&quot;</span>, address, server_name, server_name);<span class="comment">// overflow!</span></span><br><span class="line">          <span class="built_in">fputs</span>(s, tmp_file);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      fclose(stream);</span><br><span class="line">      fclose(tmp_file);</span><br><span class="line">      system(<span class="string">&quot;cp /tmp/hosts.tmp /etc/hosts 1&gt;/dev/null 2&gt;&amp;1&quot;</span>);</span><br><span class="line">      LODWORD(host_file) = system(<span class="string">&quot;rm -f /tmp/hosts.tmp 1&gt;/dev/null 2&gt;&amp;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(host_file) = fclose(stream);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> host_file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是在修改服务器名称之后对 Hosts 文件进行同步的修改，它先创建一个用于保存结果的临时文件，然后逐行读出 <code>/etc/hosts</code> 文件的内容，寻找是否包含 address 子串，然后把每一行写到临时文件，最后再用临时文件替换原来的 hosts 文件。hosts 文件的格式如下，第一栏是地址，即代码中的 address，后面两栏都是服务器名称（serv_name）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[~] # cat &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1 localhost       localhost</span><br><span class="line">192.168.0.141  CCCCCC  CCCCCC  #eth0</span><br></pre></td></tr></table></figure>
<p>在代码 23 行的位置，它通过 <code>sprintf</code> 函数组装一行数据输出到数组 s 中，其中参数 <code>server_name</code> 便是我们在请求数据中提供的。数组 s 的长度是 272，而这里显然没有对用户输入 server_name 的长度进行检查（沿着往上层函数找也没有检查），所以此处存在溢出（破案了）。</p>
<p>调用它的上层函数 <code>Set_Server_Name</code> 中也有一处很明显的漏洞，理论上可以通过构造 server_name 直接注入命令。（买一送一？）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;/bin/hostname \&quot;%s\&quot; 1&gt;/dev/null 2&gt;/dev/null&quot;</span>, server_name);</span><br><span class="line">system(s);</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="# 漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用 </h2><p> 前面也提到了这个漏洞可能只在授权条件下才有机会触发，其实是白整，这一部分主要来分析这俩漏洞利用的种种不可行性。我们先抛开授权不授权的问题，就在登录状态下尝试利用。</p>
<p>上手先试一个简单的，试一下送的那个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAA&quot;;touch &#x2F;tmp&#x2F;nuke666;echo&quot;</span><br></pre></td></tr></table></figure>
<p>构造这么一个输入，理论上可以闭合第一个双引号，然后在 /tmp 目录下创建一个文件。进行一下 URL 编码，得到 <code>AAAAA%22%3btouch+%2ftmp%2fnuke666%3becho%22</code> 这么一串，扔到 Burpsuite，提交。看一眼 /tmp 目录，哦豁，nothing！回头再网上找一找，找到 sysRequest.cgi 中对 Set_Server_Name 函数的调用，发现猫腻！这咋有个 Is_Valid_Servername？看样子像是检查一下 server_name 然后再去设置？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server_name &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Is_Valid_Servername(*(_QWORD *)(server_name + <span class="number">8</span>)) == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  Get_Server_Name(s1, <span class="number">32LL</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s1, v52) )</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v170 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)Set_Server_Name((__int64)v52, <span class="number">0LL</span>) )</span><br><span class="line">      ret_of_settingresult = <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那找一下 Is_Valid_Servername 这个函数看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nm -D -A .&#x2F;usr&#x2F;lib&#x2F;*.so | grep Is_Valid_Servername</span><br><span class="line">nm: .&#x2F;usr&#x2F;lib&#x2F;libsmbpw.so：无此文件</span><br><span class="line">nm: .&#x2F;usr&#x2F;lib&#x2F;libuLinux_ha.so：无此文件</span><br><span class="line">.&#x2F;usr&#x2F;lib&#x2F;libuLinux_Util.so:00000000000186dd T Is_Valid_Servername</span><br></pre></td></tr></table></figure>
<p>反编译得到伪代码如下。主要是调用了一个 <code>(*__ctype_b_loc())[*v2] &amp; 8</code> 这是个什么奇奇怪怪的玩意？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">Is_Valid_Servername</span><span class="params">(<span class="keyword">char</span> *server_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = server_name;</span><br><span class="line">  <span class="keyword">if</span> (!server_name)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> (*v2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (((*__ctype_b_loc())[*v2] &amp; <span class="number">8</span>) != <span class="number">0</span> )   <span class="comment">// 只允许字母和数字 isalnum()</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*v2 != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上网一查这是个判断字符的宏定义，<code>(*__ctype_b_loc())[*v2] &amp; 8</code>这一串实际上就等同于 <code>isalnum(server_name)</code>。哦豁完蛋，它<strong> 只允许字母和数字</strong>！那怪不得构造的 payload 不好使呢。那这个样子另一处漏洞不也白瞎了？师兄说有纯字母和数字的 shellcode。</p>
<p>不着急，先分析下环境。用 <a target="_blank" rel="noopener" href="https://github.com/slimm609/checksec.sh">checksec.sh</a> 这个脚本扫一下程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;checksec --file&#x3D;libuLinux_config.so.0.0 </span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE                                                                 </span><br><span class="line">No RELRO        No canary found   NX enabled    DSO             No RPATH   No RUNPATH   No Symbols        No    0               21              libuLinux_config.so.0.0</span><br></pre></td></tr></table></figure>
<p>这个库没有开启 Stack Canary，但是设置了 NX（栈不可执行），这就意味着不能把 shellcode 放在栈上去执行了，可以选择 return-to-libc 攻击。还有个东西叫 ALSR 来着不是，也看一眼</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[~] # sysctl kernel.randomize_va_space</span><br><span class="line">kernel.randomize_va_space &#x3D; 2</span><br></pre></td></tr></table></figure>
<p>哦豁，开了，那这就意味着我们没法找地址了这不是。暴力呢？这是个 64 位机……之前尝试过在 Ubuntu x64 上开启 ALSR 跑溢出，跑了 3 个小时没有命中，所以基本上没戏。</p>
<h2 id="结论"><a href="# 结论" class="headerlink" title="结论"></a>结论 </h2><p> 分析至此，这篇文章基本上就结束了。结论：白整。为了让自己死心，又去分析了下 <code>auth_get_session</code> 和<code>User_Belongs_To_Group</code>这俩函数，结果人家坚固的很。</p>
<p>虽然没有搞出什么牛 X 的洞，但也算是完整的走完了漏洞分析的整个流程，这个过程中学到的工具和技巧，是非常有价值的。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>记一次 QNAP 漏洞发现和分析</p><p><a href="https://www.nuke666.cn/2021/01/analyze-an-overflow-vulnerability-on-qnap/">https://www.nuke666.cn/2021/01/analyze-an-overflow-vulnerability-on-qnap/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChinaNuke</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/QNAP/">QNAP</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BC%8F%E6%B4%9E/">漏洞</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/how-to-use-git/"><span class="level-item">Git 基本操作</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.2/gitalk.css"><script src="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.2/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "fd419ae97ea918159c178deea3c1033b",
            repo: "chinanuke.github.io",
            owner: "ChinaNuke",
            clientID: "3f7fe9cdb9780bcf2eb8",
            clientSecret: "fa11d11f3291e3e92da34995cef1cea1eca4f60e",
            admin: ["ChinaNuke"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="ChinaNuke"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ChinaNuke</p><p class="is-size-6 is-block">合肥工业大学本科生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shandong, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/chinanuke" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/chinanuke"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="Mailto:chinanuke@nuke666.cn"><i class="far fa-envelope"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#漏洞发现"><span class="level-left"><span class="level-item">1</span><span class="level-item">漏洞发现 </span></span></a></li><li><a class="level is-mobile" href="#漏洞分析"><span class="level-left"><span class="level-item">2</span><span class="level-item">漏洞分析 </span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#提取文件系统"><span class="level-left"><span class="level-item">2.1</span><span class="level-item"> 提取文件系统 </span></span></a></li><li><a class="level is-mobile" href="#漏洞成因分析"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">漏洞成因分析 </span></span></a></li></ul></li><li><a class="level is-mobile" href="#漏洞利用"><span class="level-left"><span class="level-item">3</span><span class="level-item">漏洞利用 </span></span></a></li><li><a class="level is-mobile" href="#结论"><span class="level-left"><span class="level-item">4</span><span class="level-item">结论 </span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://huuhghhgyg.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Huuhghhgyg</span></span><span class="level-right"><span class="level-item tag">huuhghhgyg.github.io</span></span></a></li><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99/"><span class="level-start"><span class="level-item">网站</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-25T09:35:44.000Z">2021-01-25</time></p><p class="title"><a href="/2021/01/analyze-an-overflow-vulnerability-on-qnap/">记一次 QNAP 漏洞发现和分析</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-08T12:02:31.000Z">2020-09-08</time></p><p class="title"><a href="/2020/09/how-to-use-git/">Git 基本操作</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-07-22T09:18:14.000Z">2020-07-22</time></p><p class="title"><a href="/2020/07/markdown-syntax/">Markdown 基本语法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-07-21T09:12:25.000Z">2020-07-21</time></p><p class="title"><a href="/2020/07/deploy-to-upyuncdn/">Hexo 部署到又拍云 CDN</a></p><p class="categories"><a href="/categories/%E7%BD%91%E7%AB%99/">网站</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QNAP/"><span class="tag">QNAP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BC%8F%E6%B4%9E/"><span class="tag">漏洞</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">就我还用小米6了！</a><p class="is-size-7"><span>&copy; 2021 ChinaNuke</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="我的 GitHub 主页" href="https://github.com/ChinaNuke"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>